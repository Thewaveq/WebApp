<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MBOX</title>
    
    <link rel="apple-touch-icon" sizes="180x180" href="/icon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/icon/favicon-96x96.png">
    <link rel="icon" type="image/svg+xml" href="/icon/favicon.svg">
    <link rel="shortcut icon" href="/icon/favicon.ico">
    <link rel="manifest" href="/icon/site.webmanifest">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        const firebaseConfig = {
            apiKey: "__NEXT_PUBLIC_FIREBASE_API_KEY__",
            authDomain: "__NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN__",
            projectId: "__NEXT_PUBLIC_FIREBASE_PROJECT_ID__",
            storageBucket: "__NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET__",
            messagingSenderId: "__NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID__",
            appId: "__NEXT_PUBLIC_FIREBASE_APP_ID__",
            measurementId: "__NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID__"
        };
    </script>
    
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.8/dist/purify.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <script src="https://unpkg.com/split.js/dist/split.min.js"></script>
    <script src="https://unpkg.com/panzoom@9.4.3/dist/panzoom.min.js"></script>
    
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mdbassit/Coloris@latest/dist/coloris.min.css"/>
    <script src="https://cdn.jsdelivr.net/gh/mdbassit/Coloris@latest/dist/coloris.min.js"></script>
    
    <!-- Стили вынесены в отдельный файл -->
    <link rel="stylesheet" href="styles.css">

</head>
<body class="h-dvh w-full flex">

    <div id="sidebar-backdrop" class="fixed inset-0 bg-black/60 backdrop-blur-sm z-30 lg:hidden"></div>
    <aside id="sidebar" class="bg-panel flex flex-col h-full border-r border-border-color">
        <div class="h-12 px-4 flex justify-between items-center">
            <h1 class="text-xl font-bold flex items-center">
                <img src="/icon/favicon.svg" alt="Логотип MBOX" class="w-6 h-6 mr-2">MBOX
            </h1>
            <span class="text-sm text-text-secondary font-medium">V4.7</span>
        </div>
        <div class="p-2 flex-shrink-0">
            <button id="new-chat-btn" class="w-full flex items-center justify-center bg-accent hover:bg-accent-hover text-white font-bold py-2 px-4 rounded transition-colors">
                <i data-lucide="plus" class="w-5 h-5 mr-2"></i>Новый чат
            </button>
             <button id="new-note-btn" class="w-full flex items-center justify-center bg-accent hover:bg-accent-hover text-white font-bold py-2 px-4 rounded transition-colors hidden">
                <i data-lucide="plus" class="w-5 h-5 mr-2"></i>Новая папка заметок
            </button>
            <button id="new-diagram-btn" class="w-full flex items-center justify-center bg-accent hover:bg-accent-hover text-white font-bold py-2 px-4 rounded transition-colors hidden">
                <i data-lucide="plus" class="w-5 h-5 mr-2"></i>Новая диаграмма
            </button>
        </div>
        <nav id="sidebar-list" class="flex-grow overflow-y-auto p-2">
        </nav>
        <div id="auth-section" class="p-3 text-center hidden">
            <button id="google-signin-btn" class="w-full flex items-center justify-center bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded transition-colors text-sm">
                <svg class="w-4 h-4 mr-2" viewBox="0 0 48 48" fill="currentColor"><path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"></path><path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"></path><path fill="#FBBC05" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"></path><path fill="#34A853" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"></path><path fill="none" d="M0 0h48v48H0z"></path></svg>
                Войти через Google
            </button>
            <div id="user-profile" class="hidden flex items-center text-left">
                <img id="user-avatar" class="w-8 h-8 rounded-full mr-2 flex-shrink-0">
                <div class="text-xs overflow-hidden">
                    <p id="user-name" class="font-semibold text-text-primary truncate"></p>
                    <a href="#" id="sign-out-btn" class="text-red-400 hover:text-red-500">Выйти</a>
                </div>
            </div>
        </div>
    </aside>

    <main class="flex-grow flex flex-col h-full min-w-0">
        <nav class="h-12 flex-shrink-0 flex items-center px-2 bg-panel border-b border-border-color">
            <button id="sidebar-toggle-btn" class="p-3 -ml-2 hover:bg-bg-element transition-colors">
                <i id="sidebar-toggle-icon" data-lucide="panel-left-close" class="w-5 h-5"></i>
            </button>
            
            <!-- Кнопки слева -->
            <button data-tab="chat" title="Чат" class="main-nav-item p-3 rounded-md text-text-secondary hover:text-white hover:bg-bg-element transition-colors active ml-2">
                <i data-lucide="message-square" class="w-5 h-5"></i>
            </button>
            <button data-tab="notepad" title="Заметки-карточки" class="main-nav-item p-3 rounded-md text-text-secondary hover:text-white hover:bg-bg-element transition-colors">
                <i data-lucide="notebook" class="w-5 h-5"></i>
            </button>
            <button data-tab="diagrams" title="Конструктор диаграмм" class="main-nav-item p-3 rounded-md text-text-secondary hover:text-white hover:bg-bg-element transition-colors">
                <i data-lucide="git-fork" class="w-5 h-5"></i>
            </button>
        
            <!-- Кнопка справа с автоматическим отступом слева -->
            <button data-tab="settings" title="Настройки" class="main-nav-item p-3 rounded-md text-text-secondary hover:text-white hover:bg-bg-element transition-colors ml-auto">
                <i data-lucide="settings" class="w-5 h-5"></i>
            </button>
        </nav>
        <div id="main-content" class="flex-grow overflow-y-auto">
        </div>
    </main>
    
    <div id="confirm-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <p id="confirm-modal-text" class="text-text-primary mb-6 text-center">Вы уверены?</p>
            <div class="flex justify-center space-x-4">
                <button id="confirm-modal-no" class="px-6 py-2 rounded-md bg-bg-input hover:bg-gray-600 transition-colors">Нет</button>
                <button id="confirm-modal-yes" class="px-6 py-2 rounded-md bg-danger hover:bg-danger-hover text-white transition-colors">Да</button>
            </div>
        </div>
    </div>
    
    <div id="edit-provider-modal" class="modal-overlay hidden">
        <div class="modal-content !max-w-xl">
            <h3 class="text-xl font-semibold mb-4">Редактировать провайдера</h3>
            <form id="edit-provider-form" class="space-y-3">
                <input type="hidden" id="edit-provider-id">
                <div>
                    <label for="edit-provider-name" class="text-sm text-text-secondary block mb-1">Название</label>
                    <input type="text" id="edit-provider-name" class="w-full bg-input p-2 rounded border border-border-color focus:outline-none focus:ring-2 focus:ring-accent" required>
                </div>
                <div>
                    <label for="edit-provider-url" class="text-sm text-text-secondary block mb-1">Базовый URL</label>
                    <input type="text" id="edit-provider-url" class="w-full bg-input p-2 rounded border border-border-color focus:outline-none focus:ring-2 focus:ring-accent" required>
                </div>
                 <div>
                    <label for="edit-provider-path" class="text-sm text-text-secondary block mb-1">Путь запроса</label>
                    <input type="text" id="edit-provider-path" class="w-full bg-input p-2 rounded border border-border-color focus:outline-none focus:ring-2 focus:ring-accent" required>
                </div>
                <div>
                    <label for="edit-provider-keys" class="text-sm text-text-secondary block mb-1">API Ключи (каждый с новой строки)</label>
                    <textarea id="edit-provider-keys" class="w-full bg-input p-2 rounded border border-border-color focus:outline-none focus:ring-2 focus:ring-accent" rows="4" required></textarea>
                </div>
                <div>
                    <label for="edit-provider-models" class="text-sm text-text-secondary block mb-1">Модели (каждая с новой строки)</label>
                    <textarea id="edit-provider-models" class="w-full bg-input p-2 rounded border border-border-color focus:outline-none focus:ring-2 focus:ring-accent" rows="4" required></textarea>
                </div>
                <div class="flex justify-end space-x-3 pt-4">
                    <button type="button" id="edit-provider-cancel-btn" class="px-4 py-2 rounded-md bg-bg-input hover:bg-gray-600 transition-colors">Отмена</button>
                    <button type="submit" class="px-4 py-2 rounded-md bg-accent hover:bg-accent-hover text-white transition-colors">Сохранить</button>
                </div>
            </form>
        </div>
    </div>
    
    <div id="edit-role-modal" class="modal-overlay hidden">
        <div class="modal-content !max-w-xl">
            <h3 class="text-xl font-semibold mb-4">Редактировать роль</h3>
            <form id="edit-role-form" class="space-y-3">
                <input type="hidden" id="edit-role-id">
                <div>
                    <label for="edit-role-name" class="text-sm text-text-secondary block mb-1">Название роли</label>
                    <input type="text" id="edit-role-name" class="w-full bg-input p-2 rounded border border-border-color focus:outline-none focus:ring-2 focus:ring-accent" required>
                </div>
                <div>
                    <label for="edit-role-content" class="text-sm text-text-secondary block mb-1">Содержимое роли (Системный промпт)</label>
                    <textarea id="edit-role-content" class="w-full bg-input p-2 rounded border border-border-color focus:outline-none focus:ring-2 focus:ring-accent" rows="8" required></textarea>
                </div>
                <div class="flex justify-end space-x-3 pt-4">
                    <button type="button" id="edit-role-cancel-btn" class="px-4 py-2 rounded-md bg-bg-input hover:bg-gray-600 transition-colors">Отмена</button>
                    <button type="submit" class="px-4 py-2 rounded-md bg-accent hover:bg-accent-hover text-white transition-colors">Сохранить</button>
                </div>
            </form>
        </div>
    </div>
    <div id="fullscreen-modal" class="modal-overlay hidden">
        <div id="fullscreen-modal-content" class="bg-bg-main p-4 md:p-6 rounded-lg shadow-2xl w-[95vw] h-[90vh] flex flex-col">
            <!-- Кнопки -->
            <div class="flex-shrink-0 flex justify-end items-center mb-4 gap-2">
               <button id="fullscreen-width-toggle" title="Расширить" class="hidden lg:inline-flex items-center justify-center p-2 rounded-full hover:bg-bg-element transition-colors">
                    <i data-lucide="arrow-left-right" class="w-5 h-5"></i>
                </button>
                <button id="fullscreen-modal-close" class="p-2 rounded-full hover:bg-bg-element transition-colors">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>
            <!-- Контейнеры для контента -->
            <div id="fullscreen-modal-body" class="flex-grow overflow-y-auto">
                 <div id="fullscreen-prose-container" class="prose"></div>
            </div>
        </div>
    </div>
    <div id="in-app-notification" class="fixed top-9 left-1/2 -translate-x-1/2 z-50 w-full max-w-md cursor-pointer transition-all duration-300 ease-in-out transform -translate-y-[150%] opacity-0 hidden" >
        <div class="bg-bg-sidebar rounded-lg shadow-2xl border border-accent/50 p-4 mx-4 flex items-start space-x-3">
            <div class="flex-shrink-0 w-8 h-8 rounded-full bg-accent flex items-center justify-center mt-1">
                <i data-lucide="sparkles" class="w-5 h-5 text-white"></i>
            </div>
            <div class="flex-grow overflow-hidden">
                <h4 id="in-app-notification-title" class="font-bold text-text-primary text-md">Новый ответ!</h4>
                <p id="in-app-notification-body" class="text-sm text-text-secondary truncate">Получен новый ответ в чате.</p>
            </div>
            <button id="in-app-notification-close" class="flex-shrink-0 text-text-secondary hover:text-white p-1 -mr-2 -mt-2">
                <i data-lucide="x" class="w-4 h-4"></i>
            </button>
        </div>
    </div>
    <div id="auth-prompt-modal" class="modal-overlay hidden">
    <!-- ИЗМЕНЕНИЕ 1: Добавлен класс max-h-[90vh] для ограничения высоты на мобильных устройствах -->
        <div class="modal-content !max-w-4xl !p-0 flex flex-col md:flex-row overflow-hidden max-h-[90vh]">
    
            <!-- Левая колонка с вашим логотипом (без изменений) -->
            <div class="hidden md:flex flex-1 bg-bg-main items-center justify-center p-12">
                <img src="/icon/favicon.svg" alt="Логотип MBOX" class="w-40 h-40">
            </div>
    
            <!-- Правая колонка с контентом -->
            <!-- ИЗМЕНЕНИЕ 2: Добавлен класс overflow-y-auto для включения вертикальной прокрутки -->
            <div class="flex flex-col flex-1 p-8 md:p-10 overflow-y-auto">
                <h2 class="text-3xl font-bold text-text-primary mb-3">Раскройте полный потенциал MBOX</h2>
                <p class="text-text-secondary mb-8">Войдите, чтобы получить доступ ко всем возможностям и синхронизировать вашу работу.</p>
    
                <div class="space-y-5 mb-10">
                    <div class="flex items-start">
                        <i data-lucide="save" class="w-6 h-6 text-accent mr-4 flex-shrink-0 mt-1"></i>
                        <div>
                            <h3 class="font-semibold text-text-primary">Сохранение и синхронизация</h3>
                            <p class="text-sm text-text-secondary">Ваши чаты, заметки и диаграммы будут надежно сохранены и доступны с любого устройства.</p>
                        </div>
                    </div>
                    <div class="flex items-start">
                        <i data-lucide="notebook-tabs" class="w-6 h-6 text-accent mr-4 flex-shrink-0 mt-1"></i>
                        <div>
                            <h3 class="font-semibold text-text-primary">Организация рабочего процесса</h3>
                            <p class="text-sm text-text-secondary">Используйте папки с заметками и конструктор диаграмм для структурирования идей и проектов.</p>
                        </div>
                    </div>
                     <div class="flex items-start">
                        <i data-lucide="settings-2" class="w-6 h-6 text-accent mr-4 flex-shrink-0 mt-1"></i>
                        <div>
                            <h3 class="font-semibold text-text-primary">Персональные настройки</h3>
                            <p class="text-sm text-text-secondary">Настраивайте API-провайдеров, системные роли для моделей и внешний вид приложения под себя.</p>
                        </div>
                    </div>
                </div>
    
                <div class="mt-auto pt-4"> <!-- Добавлен небольшой отступ сверху для красоты при скролле -->
                     <button id="google-signin-btn-modal" class="w-full flex items-center justify-center bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition-colors text-base">
                        <svg class="w-5 h-5 mr-3" viewBox="0 0 48 48" fill="currentColor"><path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"></path><path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"></path><path fill="#FBBC05" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"></path><path fill="#34A853" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"></path><path fill="none" d="M0 0h48v48H0z"></path></svg>
                        Войти через Google
                    </button>
                     <p class="text-xs text-text-secondary text-center mt-3">Быстрый и безопасный вход. Мы никогда не будем отправлять вам спам.</p>
                </div>
            </div>
        </div>
    </div>
    <script type="module">
        // --- ИМПОРТЫ ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, onSnapshot, collection, addDoc, setDoc, deleteDoc, updateDoc, serverTimestamp, deleteField, arrayUnion, arrayRemove } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    
        // --- ИНИЦИАЛИЗАЦИЯ FIREBASE ---
        const app = initializeApp(firebaseConfig);
        
        // --- ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    
        let db = getFirestore(app);
        let auth = getAuth(app);
        let userId;
        let unsubscribeSessions = () => {};
        let unsubscribeProviders = () => {};
        let unsubscribeRoles = () => {};
        let unsubscribePipelines = () => {};
        let generationAbortController = null;
        let notificationTimeout = null;
        let attachedFile = null;
    
        let state = {
            activeTab: 'chat',
            activeSessionId: null,
            sessions: [],
            providers: [],
            roles: [],
            loadingSessionId: null,
            isAuthReady: false,
            isSidebarCollapsed: false,
            isChatWidthCompact: true,
            isNotepadWidthCompact: true,
            isSettingsPanelExpanded: false,
            isNotepadSettingsPanelExpanded: false,
        };
        
        let confirmModalCallback = null;
        
        const sidebar = document.getElementById('sidebar');
        const sidebarList = document.getElementById('sidebar-list');
        const mainContent = document.getElementById('main-content');
        const mainNavItems = document.querySelectorAll('.main-nav-item');
        const newChatBtn = document.getElementById('new-chat-btn');
        const newNoteBtn = document.getElementById('new-note-btn');
        const newDiagramBtn = document.getElementById('new-diagram-btn');
        const confirmModal = document.getElementById('confirm-modal');
        const confirmModalText = document.getElementById('confirm-modal-text');
        const confirmModalYesBtn = document.getElementById('confirm-modal-yes');
        const confirmModalNoBtn = document.getElementById('confirm-modal-no');
        const sidebarBackdrop = document.getElementById('sidebar-backdrop');
        const editProviderModal = document.getElementById('edit-provider-modal');
        const editProviderForm = document.getElementById('edit-provider-form');
        const editProviderCancelBtn = document.getElementById('edit-provider-cancel-btn');
        const editRoleModal = document.getElementById('edit-role-modal');
        const editRoleForm = document.getElementById('edit-role-form');
        const editRoleCancelBtn = document.getElementById('edit-role-cancel-btn');

        let editPipelineModal;
        let editPipelineForm;
        let editPipelineCancelBtn;

        // --- ДЛЯ ОЗВУЧИВАНИЯ ТЕКСТА ---
        let russianVoices = [];
        const synth = window.speechSynthesis;

        // --- ЭЛЕМЕНТЫ ДЛЯ АНИМАЦИИ ИНДИКАТОРА ЗАГРУЗКИ ---
        let typewriterAbortController = null;
        const typewriterPhrases = [
            "Анализирую контекст...",
            "Подбираю данные...",
            "Генерирую ответ...",
            "Проверяю результат...",
            "Завершаю обработку..."
        ];
        
        // --- СОХРАНЕНИЕ СОСТОЯНИЯ ---
         function loadUserPreferences() {
            // Загрузка настроек ширины
            const savedCompactMode = localStorage.getItem('chatViewCompact');
            if (savedCompactMode !== null) state.isChatWidthCompact = (savedCompactMode === 'true');
            const savedNotepadCompactMode = localStorage.getItem('notepadViewCompact');
            if (savedNotepadCompactMode !== null) state.isNotepadWidthCompact = (savedNotepadCompactMode === 'true');
        
            const savedAccentRGB = localStorage.getItem('userAccentRGB');
            if (savedAccentRGB) {
                document.documentElement.style.setProperty('--user-accent-rgb', savedAccentRGB);
            }

            const savedBrightness = localStorage.getItem('userAccentBrightness');
            if (savedBrightness) {
                document.documentElement.style.setProperty('--accent-brightness-strength', `${savedBrightness}%`);
            }
        }

        // НАСТРОЙКА ЦВЕТА
        function rgbStringToHex(rgbString) {
            const [r, g, b] = rgbString.split(',').map(Number);
            const toHex = c => ('0' + c.toString(16)).slice(-2);
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        function hexToRgbString(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `${r}, ${g}, ${b}`;
        }

        // --- ФУНКЦИИ ОЗВУЧКИ ---
        function loadAndSortVoices() {
            try {
                // Очищаем предыдущий список и останавливаем любое текущее воспроизведение
                if (synth.speaking) {
                    synth.cancel();
                }
                const allVoices = synth.getVoices();
                russianVoices = allVoices
                    .filter(voice => voice.lang && voice.lang.startsWith('ru'))
                    .sort((a, b) => {
                        const aIsPremium = a.name.includes('Online') || a.name.includes('neural');
                        const bIsPremium = b.name.includes('Online') || b.name.includes('neural');
                        if (aIsPremium && !bIsPremium) return -1;
                        if (!aIsPremium && bIsPremium) return 1;
                        return a.name.localeCompare(b.name);
                    });
            } catch (error) {
                console.error("Ошибка при загрузке голосов для синтеза речи:", error);
            }
        }
        
        function handleSpeakButtonClick(event) {
            event.stopPropagation();
            const speakBtn = event.target.closest('.speak-message-btn');
            if (!speakBtn) return;
        
            const controlsContainer = speakBtn.closest('.speak-controls-container');
            const dropdown = controlsContainer.querySelector('.voice-selection-dropdown');
        
            if (synth.speaking) {
                synth.cancel();
                // Иконка сама вернется в 'volume-2' по событию onend, которое сработает при отмене.
                return;
            }
        
            document.querySelectorAll('.voice-selection-dropdown').forEach(d => {
                if (d !== dropdown) {
                    d.classList.add('hidden');
                }
            });

            if (russianVoices.length > 0) {
                dropdown.innerHTML = russianVoices.map((voice, index) =>
                    `<button class="voice-option-btn w-full text-left px-3 py-2 text-sm hover:bg-bg-element transition-colors" data-voice-index="${index}">
                        ${voice.name}
                    </button>`
                ).join('');
            } else {
                dropdown.innerHTML = '<span class="block text-center text-xs text-text-secondary p-2">Русские голоса не найдены в браузере.</span>';
            }
        
            dropdown.classList.toggle('hidden');
        }

        function handleVoiceSelectionClick(event) {
            event.stopPropagation();
            const voiceOptionBtn = event.target.closest('.voice-option-btn');
            if (!voiceOptionBtn) return;
        
            const messageWrapper = voiceOptionBtn.closest('.message-container');
            const speakBtn = messageWrapper.querySelector('.speak-message-btn');
            const dropdown = voiceOptionBtn.closest('.voice-selection-dropdown');
            
            dropdown.classList.add('hidden');
        
            const contentProseEl = messageWrapper.querySelector('.prose');
            if (!contentProseEl) return;
            const contentClone = contentProseEl.cloneNode(true);
            contentClone.querySelectorAll('details').forEach(d => d.remove());
            const cleanedText = contentClone.textContent.trim();
            if (!cleanedText) return;
        
            const voiceIndex = parseInt(voiceOptionBtn.dataset.voiceIndex, 10);
            const selectedVoice = russianVoices[voiceIndex];
        
            const utterance = new SpeechSynthesisUtterance(cleanedText);
            utterance.voice = selectedVoice;
                
            const resetAllPlayingIcons = () => {
                const playingButtons = document.querySelectorAll('.speak-message-btn[data-state="playing"]');
                playingButtons.forEach(btn => {
                    delete btn.dataset.state;
                    btn.innerHTML = '<i data-lucide="volume-2" class="w-4 h-4"></i>';
                    lucide.createIcons({ nodes: [btn] });
                });
            };
        
            utterance.onstart = () => {
                resetAllPlayingIcons();
        
                speakBtn.dataset.state = 'playing';
                speakBtn.innerHTML = '<i data-lucide="square" class="w-4 h-4"></i>';
                lucide.createIcons({ nodes: [speakBtn] });
            };
        
            const onPlaybackEnd = () => {
                delete speakBtn.dataset.state;
                speakBtn.innerHTML = '<i data-lucide="volume-2" class="w-4 h-4"></i>';
                lucide.createIcons({ nodes: [speakBtn] });
            };
        
            utterance.onend = onPlaybackEnd;
            utterance.onerror = (e) => {
                console.error('Ошибка синтеза речи:', e);
                onPlaybackEnd();
            };
        
            synth.cancel();
            synth.speak(utterance);
        }

        // ИНДИКАТОР ПЕЧАТИ
        async function typeWriter(element, signal) {
            if (!element) return;
            const typeSpeed = 80;
            const eraseSpeed = 40;
            const newPhraseDelay = 2000;
            let phraseIndex = 0;
        
            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
        
            try {
                while (!signal.aborted) {
                    const currentPhrase = typewriterPhrases[phraseIndex];
                    // Печать текста
                    for (let charIndex = 0; charIndex < currentPhrase.length; charIndex++) {
                        if (signal.aborted) return;
                        element.textContent = currentPhrase.substring(0, charIndex + 1);
                        await sleep(typeSpeed);
                    }
                    if (signal.aborted) return;
                    await sleep(newPhraseDelay);
                    // Стирание текста
                    for (let charIndex = currentPhrase.length; charIndex > 0; charIndex--) {
                        if (signal.aborted) return;
                        element.textContent = currentPhrase.substring(0, charIndex - 1);
                        await sleep(eraseSpeed);
                    }
                    phraseIndex = (phraseIndex + 1) % typewriterPhrases.length;
                    if (signal.aborted) return;
                    await sleep(500);
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error("Ошибка в цикле анимации:", error);
                }
            }
        }
        
        // --- ФУНКЦИИ РЕНДЕРИНГА ---
        function render() {
            if (!state.isAuthReady) return;
            renderSidebar();
            renderMainContent();
            renderMainNav();
        }
    
        function renderSidebar() {
            sidebarList.innerHTML = '';
            const filteredSessions = state.sessions.filter(s => s.type === state.activeTab);
            const isMobile = window.innerWidth < 1024;
        
            if (filteredSessions.length > 0) {
                filteredSessions.forEach(session => {
                    const item = document.createElement('div');
                    const isActive = session.id === state.activeSessionId;

                    item.className = `sidebar-item flex justify-between items-center p-2 my-1 rounded-md cursor-pointer transition-colors duration-200 ${isActive ? 'active' : ''}`;
                    
                    item.innerHTML = `
                        <span class="truncate pr-2">${session.title || 'Без названия'}</span>
                        <button class="delete-session-btn hidden text-text-secondary hover:text-red-400" data-id="${session.id}">
                            <i data-lucide="trash-2" class="w-4 h-4"></i>
                        </button>
                    `;
                    
                    const deleteBtn = item.querySelector('.delete-session-btn');

                    if (isMobile && isActive) {
                        deleteBtn.classList.remove('hidden');
                    }
                    
                    item.addEventListener('click', (e) => {
                        if (e.target.closest('.delete-session-btn')) return;
                        state.activeSessionId = session.id;
                        render(); 
                    });
                    
                    item.addEventListener('mouseenter', () => {
                        if (!isMobile) {
                            deleteBtn.classList.remove('hidden');
                        }
                    });
                    
                    item.addEventListener('mouseleave', () => {
                        if (!isMobile) {
                            deleteBtn.classList.add('hidden');
                        }
                    });
                    
                    sidebarList.appendChild(item);
                });
            } else if (state.activeTab === 'chat' || state.activeTab === 'notepad') {
                 const typeTextMap = {
                     chat: 'чатов',
                     notepad: 'папок с заметками',
                     diagrams: 'диаграмм' 
                 };
                 sidebarList.innerHTML = `<div class="text-center text-sm text-gray-500 p-4">Нет ${typeTextMap[state.activeTab] || 'элементов'}.</div>`;
            } else {
                 sidebarList.innerHTML = ''; 
            }
            lucide.createIcons();
        }
    
        function renderMainContent() {

            const activeSession = state.sessions.find(s => s.id === state.activeSessionId);
            const needsFullRender = mainContent.dataset.activeTabType !== state.activeTab || mainContent.dataset.activeSessionId !== (state.activeSessionId || '');

            if (!needsFullRender && activeSession) {
                 if (state.activeTab === 'chat') {

                    renderChatMessages(activeSession);
                    updateLoadingIndicator();
                 } else if (state.activeTab === 'notepad') {

                    renderNotepadCards(activeSession);
                 }
                 return;
            }

            mainContent.innerHTML = '';
            mainContent.dataset.activeTabType = state.activeTab;
            mainContent.dataset.activeSessionId = state.activeSessionId || '';

            switch (state.activeTab) {
                case 'chat':
                    if (activeSession) {
                        const chatContainer = document.createElement('div');
                        chatContainer.id = 'chat-view-container';
                        chatContainer.className = 'flex flex-col h-full';
                        chatContainer.innerHTML = getChatViewHTML(activeSession);
                        mainContent.appendChild(chatContainer);

                        const provider = state.providers.find(p => p.id === activeSession.providerId);
                        let needsUpdate = false;
                        const updatePayload = {};

                        if (!provider && state.providers.length > 0) {
                            const firstProvider = state.providers[0];
                            const models = firstProvider.models || [];
                            updatePayload.providerId = firstProvider.id;
                            updatePayload.modelName = models.length > 0 ? models[0] : null;
                            needsUpdate = true;
                        } else if (provider && !activeSession.modelName) {
                            const models = provider.models || [];
                            if (models.length > 0) {
                                updatePayload.modelName = models[0];
                                needsUpdate = true;
                            }
                        }

                        if (needsUpdate) {
                            const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
                            updateDoc(sessionRef, updatePayload);
                        }

                        renderChatMessages(activeSession);
                        setupChatViewEventListeners();
                        updateLoadingIndicator();
                        
                        const messagesContainer = document.getElementById('chat-messages');
                        if (messagesContainer) {
                            setTimeout(() => {
                                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                            }, 0);
                        }
                    } else {
                         mainContent.innerHTML = getEmptyStateHTML('chat');
                    }
                    break;
                case 'notepad':
                     if (activeSession) {
                        mainContent.innerHTML = getNotepadViewHTML(activeSession);
                        setupNotepadViewEventListeners();

                        const scrollContainer = document.getElementById('notepad-scroll-container');
                        if(scrollContainer) {

                            setTimeout(() => {
                               scrollContainer.scrollTop = scrollContainer.scrollHeight;
                            }, 0);
                        }
                    } else {
                        mainContent.innerHTML = getEmptyStateHTML('notepad');
                    }
                    break;
                case 'diagrams':
                     if (activeSession) {
                        mainContent.innerHTML = getDiagramsViewHTML(activeSession);
                        setupDiagramsViewEventListeners();
                    } else {
                        mainContent.innerHTML = getEmptyStateHTML('diagrams');
                    }
                    break;  
                case 'settings':
                    mainContent.innerHTML = getSettingsViewHTML();
                    renderProviders();
                    renderRoles();
                    renderPipelines();
                    setupSettingsViewEventListeners();
                    break;
            }
            lucide.createIcons();
        }
        
        function renderMainNav() {
            mainNavItems.forEach(item => {
                item.classList.toggle('active', item.dataset.tab === state.activeTab);
            });
            newChatBtn.classList.toggle('hidden', state.activeTab !== 'chat');
            newNoteBtn.classList.toggle('hidden', state.activeTab !== 'notepad');
            newDiagramBtn.classList.toggle('hidden', state.activeTab !== 'diagrams');
        }

        function renderNotepadCards(session) {
            const cardsGrid = document.getElementById('note-cards-grid');
            if (!cardsGrid) return;
        

            function autoResizeTextarea(textarea) {
                if (!textarea) return;

                setTimeout(() => {
                    textarea.style.height = 'auto';
                    textarea.style.height = (textarea.scrollHeight) + 'px';
                }, 0);
            }
        
            const newCards = session.cards || [];
            const newCardIds = new Set(newCards.map(c => c.id));
            const addButton = document.getElementById('add-new-card-btn');
        

            const existingCardElements = cardsGrid.querySelectorAll('.note-card');
            existingCardElements.forEach(cardEl => {
                const cardId = cardEl.dataset.cardId;
                if (!newCardIds.has(cardId)) {
                    cardEl.remove();
                }
            });
        

            newCards.forEach((cardData, index) => {
                let cardEl = cardsGrid.querySelector(`.note-card[data-card-id="${cardData.id}"]`);
        
                if (cardEl) {

                    const titleInput = cardEl.querySelector('.note-card-title');
                    const contentTextarea = cardEl.querySelector('.note-card-content');
                    
                    if (document.activeElement !== titleInput && titleInput.value !== cardData.title) {
                        titleInput.value = cardData.title || '';
                    }
                    if (document.activeElement !== contentTextarea && contentTextarea.value !== cardData.content) {
                        contentTextarea.value = cardData.content || '';

                        autoResizeTextarea(contentTextarea);
                    }
                } else {

                    const newCardHTML = getCardHTML(cardData);
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = newCardHTML;
                    const newCardElement = tempDiv.firstElementChild;
                    
                    cardsGrid.insertBefore(newCardElement, addButton);
                    lucide.createIcons({ nodes: [newCardElement] });
                    
                    const newTextarea = newCardElement.querySelector('.note-card-content');
                    autoResizeTextarea(newTextarea);
                }
            });
        }

        function renderPipelines() {
            const list = document.getElementById('pipelines-list');
            if (!list) return;

            // Проверяем, есть ли пайплайны
            if (!state.pipelines || state.pipelines.length === 0) {
                list.innerHTML = `<p class="text-text-secondary md:col-span-2 xl:col-span-3 text-center py-10">Нет созданных пайплайнов. Нажмите "Создать пайплайн", чтобы начать.</p>`;
                return;
            }

            // Генерируем HTML для каждого пайплайна
            list.innerHTML = state.pipelines.map(p => {
                const stepCount = (p.steps && p.steps.length) > 0 ? p.steps.length : 0;
                const stepSummary = stepCount > 0 
                    ? (p.steps.map(s => s.modelName || 'Модель').join(' → '))
                    : 'Нет шагов';

                return `
                <div class="bg-bg-sidebar rounded-lg border border-border-color p-4 flex flex-col justify-between h-full transition-shadow hover:shadow-lg hover:border-accent/50">
                    <div>
                        <div class="flex justify-between items-start mb-3">
                             <h3 class="font-bold text-lg pr-2">${p.name || 'Безымянный пайплайн'}</h3>
                             <div class="flex items-center space-x-1 flex-shrink-0">
                                <button class="edit-pipeline-btn p-1.5 text-text-secondary hover:text-accent transition-colors" data-id="${p.id}"><i data-lucide="edit" class="w-4 h-4"></i></button>
                                <button class="delete-pipeline-btn p-1.5 text-text-secondary hover:text-red-400 transition-colors" data-id="${p.id}"><i data-lucide="trash-2" class="w-4 h-4"></i></button>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex items-center text-text-secondary"><i data-lucide="layers" class="w-4 h-4 mr-2 flex-shrink-0"></i><span class="font-semibold text-text-primary mr-2">Шагов:</span> ${stepCount}</div>
                            <div class="flex items-start text-text-secondary">
                                <i data-lucide="route" class="w-4 h-4 mr-2 mt-0.5 flex-shrink-0"></i>
                                <span class="font-semibold text-text-primary mr-2">Маршрут:</span> 
                                <span class="break-all truncate">${stepSummary}</span>
                            </div>
                        </div>
                    </div>
                </div>
                `
            }).join(''); 
            lucide.createIcons(); 
        }
    
        // --- ШАБЛОНЫ HTML ---
        function getEmptyStateHTML(type) {
            const iconMap = {
                'chat': 'message-square',
                'notepad': 'notebook',
                'diagrams': 'git-fork'
            };
            const textMap = {
                'chat': 'Выберите чат или создайте новый',
                'notepad': 'Выберите папку с заметками-карточками или создайте новую',
                'diagrams': 'Выберите диаграмму или создайте новую'
            };
            const icon = iconMap[type] || 'alert-circle';
            const text = textMap[type] || 'Выберите элемент';
            return `<div class="flex flex-col h-full items-center justify-center text-gray-500 text-center p-4"><i data-lucide="${icon}" class="w-16 h-16 mb-4"></i><h2 class="text-2xl">${text}</h2></div>`;
        }
        
        function getChatViewHTML(activeSession) { 
            // --- Существующий код для опций ---
            const roleOptions = state.roles.map(r => `<option value="${r.id}" ${r.id === activeSession.roleId ? 'selected' : ''}>${r.name}</option>`).join('');
            const providerOptions = state.providers.map(p => `<option value="${p.id}" ${p.id === activeSession.providerId ? 'selected' : ''}>${p.name}</option>`).join('');
            
            let modelOptions = '<option disabled>Выберите провайдера</option>';
            const selectedProvider = state.providers.find(p => p.id === activeSession.providerId);
            if (selectedProvider) {
                const models = selectedProvider.models || [];
                if (models.length > 0) {
                   modelOptions = models.map(m => `<option value="${m}" ${m === activeSession.modelName ? 'selected' : ''}>${m}</option>`).join('');
                } else {
                   modelOptions = '<option disabled>Нет моделей</option>';
                }
            }

            // --- НОВЫЙ КОД: Опции для выбора пайплайна ---
            const pipelineOptions = (state.pipelines || []).map(p => `<option value="${p.id}" ${p.id === activeSession.pipelineId ? 'selected' : ''}>${p.name}</option>`).join('');

            const isSettingsPanelVisible = state.isSettingsPanelExpanded;

            // Определяем, активен ли режим пайплайна
            const isPipelineMode = !!activeSession.pipelineId;
        
            return `
            <div class="flex flex-col h-full relative overflow-hidden" id="chat-view-container">
                
                <!-- Плавающие кнопки управления -->
                <div class="absolute top-3 right-3 z-30 flex items-center gap-2">
                    <button id="chat-width-toggle" title="Переключить ширину чата" class="chat-action-btn hidden lg:flex">
                        <i data-lucide="arrow-left-right" class="w-4 h-4"></i>
                    </button>
                    <button id="chat-settings-toggle" title="Настройки чата" class="chat-action-btn">
                        <i data-lucide="settings-2" id="chat-settings-icon" class="w-4 h-4 transition-transform duration-300 ${isSettingsPanelVisible ? 'rotate-90' : ''}"></i>
                    </button>
                </div>

                <!-- Оверлей для перетаскивания, покрывает всю область -->
                <div id="drop-overlay" class="absolute inset-0 bg-black/60 backdrop-blur-sm border-4 border-dashed border-accent rounded-lg flex flex-col items-center justify-center text-white font-bold text-2xl hidden z-40">
                    <i data-lucide="file-down" class="w-16 h-16 mb-4"></i>
                    <span>Перетащите файл для прикрепления</span>
                </div>

                <!-- Плавающая панель настроек -->
                <div id="chat-settings-panel" class="absolute top-16 right-3 z-20 w-[calc(100%-1.5rem)] max-w-sm bg-bg-sidebar/90 backdrop-blur-xl border border-border-color rounded-lg shadow-2xl p-4 transition-all duration-300 transform ${isSettingsPanelVisible ? 'opacity-100 translate-y-0' : 'opacity-0 -translate-y-4 pointer-events-none'}">
                    <div class="flex justify-between items-center border-b border-border-color pb-3 mb-4">
                        <h3 class="font-bold text-lg">Настройки чата</h3>
                        <button id="clear-chat-history-btn" title="Очистить историю чата" class="flex-shrink-0 p-2 rounded-full text-text-secondary hover:text-danger hover:bg-danger/10 transition-colors -mr-2">
                            <i data-lucide="rotate-cw" class="w-4 h-4"></i>
                        </button>
                    </div>
                    <div>
                        <label for="chat-title-input" class="text-sm font-medium text-text-secondary block mb-1">Название чата</label>
                        <input type="text" id="chat-title-input" class="w-full bg-input p-2 rounded border border-border-color focus:outline-none focus:ring-2 focus:ring-accent" value="${activeSession.title || ''}" placeholder="Название чата">
                    </div>

                    <div class="pt-4 mt-4 border-t border-border-color">
                        <label for="pipeline-select" class="text-sm font-medium text-text-secondary block mb-1">Пайплайн</label>
                        <select id="pipeline-select" class="w-full bg-input border border-border-color rounded p-2 text-sm focus:outline-none focus:ring-2 focus:ring-accent">
                            <option value="">Не выбран</option>
                            ${pipelineOptions}
                        </select>
                    </div>

                    <div id="single-model-settings" class="space-y-4 pt-4 mt-4 border-t border-border-color ${isPipelineMode ? 'opacity-50 pointer-events-none' : ''}">
                         <p class="text-sm font-medium text-text-secondary -mb-2">Одиночная модель</p>
                        <div>
                            <label for="role-select" class="text-xs text-text-secondary block mb-1">Роль</label>
                            <select id="role-select" class="w-full bg-input border border-border-color rounded p-2 text-sm focus:outline-none focus:ring-2 focus:ring-accent" ${isPipelineMode ? 'disabled' : ''}>
                                <option value="">Без роли</option>
                                ${roleOptions}
                            </select>
                        </div>
                        <div>
                            <label for="provider-select" class="text-xs text-text-secondary block mb-1">Провайдер</label>
                            <select id="provider-select" class="w-full bg-input border border-border-color rounded p-2 text-sm focus:outline-none focus:ring-2 focus:ring-accent" ${isPipelineMode ? 'disabled' : ''}>
                                ${providerOptions.length > 0 ? providerOptions : '<option disabled>Добавьте провайдера</option>'}
                            </select>
                        </div>
                        <div>
                            <label for="model-select" class="text-xs text-text-secondary block mb-1">Модель</label>
                            <select id="model-select" class="w-full bg-input border border-border-color rounded p-2 text-sm focus:outline-none focus:ring-2 focus:ring-accent" ${isPipelineMode ? 'disabled' : ''}>
                                ${modelOptions}
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Область чата (ОРИГИНАЛЬНАЯ СТРУКТУРА) -->
                <div class="flex-grow relative min-h-0">
                    <div id="chat-messages" class="absolute inset-0 p-4 overflow-y-auto ${state.isChatWidthCompact ? 'chat-view-compact' : ''}"></div>
                    <form id="chat-form" class="absolute bottom-0 left-0 right-0 p-4 bg-transparent">
                        <div class="relative w-full max-w-4xl mx-auto">
                             <!-- Контейнер для предпросмотра файла, вставлен сюда -->
                            <div id="attachment-preview-container" class="pb-2"></div>
                            <textarea id="chat-input" class="w-full bg-input border border-border-color rounded-xl p-3 pr-12 resize-none focus:outline-none focus:ring-2 focus:ring-accent min-h-[50px]" placeholder="Введите сообщение" rows="1"></textarea>
                            <button type="submit" class="absolute right-3 bottom-3 p-2 rounded-full bg-accent hover:bg-accent-hover transition-colors disabled:bg-gray-500">
                                <i data-lucide="send" class="w-5 h-5 text-white"></i>
                            </button>
                        </div>
                    </form>
                </div>
            </div>`; 
        }

        function getDiagramsViewHTML(activeSession) {
            const code = activeSession.code || '';
            return `
            <div id="diagram-editor-container" class="flex flex-col lg:flex-row h-full w-full">
                <div id="diagram-code-panel" class="flex flex-col w-full h-1/2 lg:w-1/2 lg:h-full border-b lg:border-r lg:border-b-0 border-border-color min-h-0 overflow-hidden">
                    <div class="p-3 border-b border-border-color flex-shrink-0">
                        <input type="text" id="diagram-title-input" class="w-full bg-transparent font-bold text-lg focus:outline-none" value="${activeSession.title || ''}" placeholder="Название диаграммы">
                    </div>
                    <textarea id="diagram-input" class="w-full h-full bg-input p-4 resize-none focus:outline-none font-mono text-sm" wrap="off">${code}</textarea>
                </div>
        
                <div id="diagram-preview-panel" class="relative flex flex-col w-full h-1/2 lg:w-1/2 lg:h-full min-h-0 overflow-hidden">
                     <div class="p-3 border-b border-border-color flex-shrink-0 flex justify-between items-center">
                        <h3 class="font-semibold text-lg">Результат</h3>
                        <div id="diagram-error-container" class="text-xs text-red-400"></div>
                     </div>
                     <div id="diagram-output" class="w-full h-full p-4 overflow-hidden flex items-center justify-center bg-bg-main">
                     </div>
                </div>
            </div>
            `;
        }
        
        function showFullscreenMessage(content) {
            const modal = document.getElementById('fullscreen-modal');
            const modalBody = document.getElementById('fullscreen-modal-body');
            const proseContainer = document.getElementById('fullscreen-prose-container');
            const widthToggleBtn = document.getElementById('fullscreen-width-toggle');
        
            if (!modal || !modalBody || !proseContainer || !widthToggleBtn) return;
            
            modalBody.classList.add('fullscreen-view-compact');
            widthToggleBtn.classList.remove('active');
            widthToggleBtn.title = 'Расширить';
        
            const newWidthToggleBtn = widthToggleBtn.cloneNode(true);
            widthToggleBtn.parentNode.replaceChild(newWidthToggleBtn, widthToggleBtn);

            if (window.innerWidth < 1024) {
                newWidthToggleBtn.style.display = 'none';
            }
            newWidthToggleBtn.classList.remove('active');
            newWidthToggleBtn.title = 'Расширить';
            
            newWidthToggleBtn.addEventListener('click', () => {
                const isNowCompact = modalBody.classList.toggle('fullscreen-view-compact');
                newWidthToggleBtn.classList.toggle('active', !isNowCompact);
                newWidthToggleBtn.title = isNowCompact ? 'Расширить' : 'Вернуть компактный вид';
            });
        
            let processedContent = (content || '').replace(
                /<think>([\s\S]*?)<\/think>/g,
                `<details><summary>Показать ход мыслей</summary><div>$1</div></details>`
            );
            const rawHtml = marked.parse(processedContent, { breaks: true, gfm: true });
            proseContainer.innerHTML = DOMPurify.sanitize(rawHtml, { ADD_TAGS: ['details', 'summary'] });
        
            proseContainer.querySelectorAll('pre code').forEach((block) => {
                const preElement = block.parentElement;
                if (preElement.querySelector('.copy-code-btn')) return;
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-code-btn';
                copyBtn.innerHTML = '<i data-lucide="copy" class="w-4 h-4"></i>';
                copyBtn.addEventListener('click', () => {
                    navigator.clipboard.writeText(block.innerText);
                    copyBtn.innerHTML = '<i data-lucide="check" class="w-4 h-4 text-green-400"></i>';
                    setTimeout(() => { copyBtn.innerHTML = '<i data-lucide="copy" class="w-4 h-4"></i>'; lucide.createIcons(); }, 2000);
                    lucide.createIcons();
                });
                preElement.appendChild(copyBtn);
                hljs.highlightElement(block);
            });
            
            modal.classList.remove('hidden');
            lucide.createIcons();
        }

        function hideFullscreenMessage() {
            const modal = document.getElementById('fullscreen-modal');
            const modalBody = document.getElementById('fullscreen-modal-body');
            if (modal) {
                modal.classList.add('hidden');
            }
            const proseContainer = document.getElementById('fullscreen-prose-container');
            if (proseContainer) {
                proseContainer.innerHTML = '';
            }
        }
        
        function getNotepadViewHTML(activeSession) {
            const cards = activeSession.cards || [];
            const cardsHTML = cards.map(getCardHTML).join('');
            const isSettingsPanelVisible = state.isNotepadSettingsPanelExpanded || false;
        
            return `
                <div class="flex flex-col h-full relative overflow-hidden" id="notepad-view-container">
                    
                    <!-- Плавающие кнопки управления (по аналогии с чатом) -->
                    <div class="absolute top-3 right-3 z-30 flex items-center gap-2">
                        <button id="notepad-width-toggle" title="Переключить ширину контента" class="chat-action-btn hidden lg:flex">
                            <i data-lucide="arrow-left-right" class="w-4 h-4"></i>
                        </button>
                        <button id="notepad-settings-toggle" title="Настройки папки" class="chat-action-btn">
                            <i data-lucide="settings-2" id="notepad-settings-icon" class="w-5 h-5 transition-transform duration-300 ${isSettingsPanelVisible ? 'rotate-90' : ''}"></i>
                        </button>
                    </div>
        
                    <!-- Плавающая панель настроек (по аналогии с чатом) -->
                    <div id="notepad-settings-panel" class="absolute top-16 right-3 z-20 w-[calc(100%-1.5rem)] max-w-sm bg-bg-sidebar/90 backdrop-blur-xl border border-border-color rounded-lg shadow-2xl p-4 space-y-4 transition-all duration-300 transform ${isSettingsPanelVisible ? 'opacity-100 translate-y-0' : 'opacity-0 -translate-y-4 pointer-events-none'}">
                        <h3 class="font-bold text-lg border-b border-border-color pb-3 mb-4">Настройки папки</h3>
                        <div>
                            <label for="note-title-input" class="text-sm font-medium text-text-secondary block mb-1">Название папки</label>
                            <input type="text" id="note-title-input" class="w-full bg-input p-2 rounded border border-border-color focus:outline-none focus:ring-2 focus:ring-accent" value="${activeSession.title || ''}" placeholder="Название папки с заметками">
                        </div>
                    </div>
                    
                    <!-- Основная область с карточками -->
                    <div id="notepad-scroll-container" class="flex-grow overflow-y-auto p-4 ${state.isNotepadWidthCompact ? 'notepad-view-compact' : ''}">
                        <div id="note-cards-grid" class="grid grid-cols-1 gap-4 items-start">
                            ${cardsHTML}
                            <button id="add-new-card-btn" class="add-card-placeholder flex items-center justify-center rounded-lg border-2 border-dashed border-border-color hover:bg-bg-element transition-colors text-text-secondary p-4 min-h-[120px]">
                                <i data-lucide="plus" class="w-10 h-10"></i>
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function getCardHTML(card) {
            const title = card.title ? card.title.replace(/"/g, '"') : '';
            const content = card.content || '';

            return `
                <div class="note-card bg-bg-sidebar rounded-lg border border-border-color p-3 flex flex-col gap-2 transition-shadow hover:shadow-lg hover:border-accent/50" data-card-id="${card.id}">
                    <div class="note-card-header flex items-center justify-between">
                        <input type="text" class="note-card-title bg-transparent font-bold w-full focus:outline-none" placeholder="Заголовок" value="${title}">
                        <button class="note-card-delete-btn flex-shrink-0 text-text-secondary hover:text-red-400 ml-2" title="Удалить карточку">
                            <i data-lucide="x" class="w-4 h-4"></i>
                        </button>
                    </div>
                    <textarea class="note-card-content bg-transparent w-full resize-none focus:outline-none overflow-hidden text-sm" placeholder="Содержимое карточки...">${content}</textarea>
                </div>
            `;
        }
        
        function createMessageElement(msg, index) {
            const isUser = msg.role === 'user';
            const messageWrapper = document.createElement('div');
            const contentAsString = String(msg.content || ''); 
            
            messageWrapper.dataset.content = contentAsString;
            
            const fileRegex = /<file name="([^"]+)">([\s\S]*)<\/file>/;
            const fileMatch = contentAsString.match(fileRegex);
        
            if (isUser && fileMatch) {
                const fileName = fileMatch[1];
                messageWrapper.className = 'message-container group relative flex flex-col mb-6 items-end';
                const plaque = document.createElement('div');
                plaque.className = 'user-message-bg rounded-xl max-w-md p-3 flex items-center justify-between gap-2';
                const fileInfo = document.createElement('div');
                fileInfo.className = 'flex items-center min-w-0';
                fileInfo.innerHTML = `
                    <i data-lucide="paperclip" class="w-4 h-4 mr-2 flex-shrink-0 text-accent"></i>
                    <span class="font-medium truncate">${DOMPurify.sanitize(fileName)}</span>
                `;
                plaque.appendChild(fileInfo);
                const deleteButton = document.createElement('button');
                deleteButton.className = 'p-1 text-text-secondary hover:text-red-400 delete-message-btn flex-shrink-0';
                deleteButton.title = 'Удалить';
                deleteButton.dataset.messageIndex = index;
                deleteButton.innerHTML = `<i data-lucide="trash-2" class="w-4 h-4"></i>`;
                plaque.appendChild(deleteButton);
                messageWrapper.appendChild(plaque);
                lucide.createIcons({ nodes: [messageWrapper] });
                return messageWrapper;
            }
        
            const baseClasses = 'message-container group relative flex flex-col mb-6 p-4 rounded-xl';
            const roleSpecificClasses = isUser ? 'user-message-bg items-end' : 'assistant-message-bg items-start';
            messageWrapper.className = `${baseClasses} ${roleSpecificClasses}`;
            const headerDiv = document.createElement('div');
            headerDiv.className = `flex items-center space-x-3`;
            const iconDiv = document.createElement('div');
            iconDiv.className = `w-7 h-7 rounded-full flex-shrink-0 flex items-center justify-center overflow-hidden`;
        
            if (isUser) {
                const user = auth.currentUser;
                const userNameSpan = document.createElement('span');
                userNameSpan.className = 'text-sm text-text-secondary'; 
                userNameSpan.textContent = user?.displayName || 'Вы';
                headerDiv.appendChild(userNameSpan);
                const avatarSrc = user?.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(user?.displayName || 'U')}&background=4285F4&color=fff`;
                iconDiv.innerHTML = `<img src="${avatarSrc}" alt="Аватар пользователя" class="w-full h-full object-cover">`;
                headerDiv.appendChild(iconDiv);
            } else {
                iconDiv.classList.add('bg-accent');
                iconDiv.innerHTML = `<i data-lucide="sparkles" class="w-4 h-4 text-white"></i>`;
                headerDiv.appendChild(iconDiv);
                if (msg.modelName) {
                    const modelNameSpan = document.createElement('span');
                    modelNameSpan.className = 'text-sm text-text-secondary';
                    modelNameSpan.textContent = msg.modelName;
                    headerDiv.appendChild(modelNameSpan);
                }
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'prose max-w-none mt-2 w-full';
            
            contentDiv.innerHTML = '';
        
            if (msg.pipelineTrace) {
                const traceContent = marked.parse(msg.pipelineTrace, { breaks: true, gfm: true });
                const traceDetailsHtml = `
                    <details>
                        <summary>Показать ход выполнения пайплайна</summary>
                        <div>${traceContent}</div>
                    </details>`;
                
                const mainContent = marked.parse(String(msg.content || ''), { breaks: true, gfm: true });
            
                const combinedHtml = traceDetailsHtml + mainContent;
                contentDiv.innerHTML = DOMPurify.sanitize(combinedHtml, { ADD_TAGS: ['details', 'summary'] });
        
            } else {
                const processedContent = String(msg.content || '').replace(
                    /<think>([\s\S]*?)<\/think>/g,
                    `<details><summary>Показать ход мыслей</summary><div>$1</div></details>`
                );
                const rawHtml = marked.parse(processedContent, { breaks: true, gfm: true });
                contentDiv.innerHTML = DOMPurify.sanitize(rawHtml, { ADD_TAGS: ['details', 'summary'] });
            }
            
            const actionsOuterContainer = document.createElement('div');
            actionsOuterContainer.className = 'absolute bottom-1 right-2 flex items-center bg-bg-element p-1 rounded-md opacity-0 group-hover:opacity-100 transition-opacity z-10';
            const actionsContainer = document.createElement('div');
            actionsContainer.className = 'message-actions-container';
            const dropdownMenu = document.createElement('div');
            dropdownMenu.className = 'message-actions-dropdown hidden';
        
            const createMenuItem = (icon, text, customClass = '', dataset = {}) => {
                const button = document.createElement('button');
                button.className = `dropdown-menu-item ${customClass}`;
                button.innerHTML = `<i class="mr-2"></i><span class="text-left flex-grow">${text}</span>`;
                button.querySelector('i').setAttribute('data-lucide', icon);
                Object.keys(dataset).forEach(key => button.dataset[key] = dataset[key]);
                return button;
            };
        
            if (isUser) {
                dropdownMenu.appendChild(createMenuItem('refresh-cw', 'Перегенерировать ответ', 'regenerate-user-message-btn', { messageIndex: index }));
                dropdownMenu.appendChild(createMenuItem('pencil', 'Редактировать и отправить', 'edit-message-btn', { messageIndex: index }));
            } else {
                dropdownMenu.appendChild(createMenuItem('refresh-cw', 'Перегенерировать ответ', 'regenerate-message-btn', { messageIndex: index }));
            }
            
            dropdownMenu.appendChild(createMenuItem('file-plus-2', 'Скопировать в заметки')).addEventListener('click', async () => {
                const contentToCopy = msg.content;
                if (!contentToCopy) return;
                const quickNotesTitle = 'Быстрые заметки';
                let quickNotesSession = state.sessions.find(s => s.type === 'notepad' && s.title === quickNotesTitle);
                let sessionId;
                if (quickNotesSession) {
                    sessionId = quickNotesSession.id;
                } else {
                    const newSessionData = { type: 'notepad', title: quickNotesTitle, cards: [], createdAt: serverTimestamp(), updatedAt: serverTimestamp() };
                    const newSessionRef = await addDoc(collection(db, `artifacts/${appId}/users/${userId}/sessions`), newSessionData);
                    sessionId = newSessionRef.id;
                }
                const newCard = { id: 'card_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9), title: contentToCopy.substring(0, 40).replace(/\n/g, ' ') + '...', content: contentToCopy, createdAt: new Date().toISOString() };
                const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, sessionId);
                await updateDoc(sessionRef, { cards: arrayUnion(newCard), updatedAt: serverTimestamp() });
                showInAppNotification('Скопировано!', `Сообщение добавлено в папку "${quickNotesTitle}"`, sessionId);
            });
            
            dropdownMenu.appendChild(createMenuItem('clipboard', 'Копировать текст'))
                .addEventListener('click', function() {
                    const buttonElement = this;
        
                    navigator.clipboard.writeText(msg.content).then(() => {
                        const originalHTML = buttonElement.innerHTML;
        
                        buttonElement.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="text-green-400 mx-auto"><polyline points="20 6 9 17 5 12"></polyline></svg>`;
        
                        setTimeout(() => {
                            if (document.body.contains(buttonElement)) {
                                buttonElement.innerHTML = originalHTML;
                            }
                        }, 2000);
                    }).catch(err => console.error('Не удалось скопировать текст:', err));
                });
            
            const separator = document.createElement('hr');
            separator.className = 'dropdown-menu-separator';
            dropdownMenu.appendChild(separator);
            dropdownMenu.appendChild(createMenuItem('trash-2', 'Удалить сообщение', 'danger delete-message-btn', { messageIndex: index }));
            const moreOptionsBtn = document.createElement('button');
            moreOptionsBtn.className = 'p-1 text-text-secondary hover:text-accent transition-colors';
            moreOptionsBtn.title = 'Дополнительно';
            moreOptionsBtn.innerHTML = `<i data-lucide="more-vertical" class="w-4 h-4"></i>`;
            
            moreOptionsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                dropdownMenu.classList.toggle('hidden');
                if (!dropdownMenu.classList.contains('hidden')) {
                    dropdownMenu.style.top = '';
                    dropdownMenu.style.bottom = '100%';
                    dropdownMenu.style.marginTop = '';
                    dropdownMenu.style.marginBottom = '8px';
        
                    const menuRect = dropdownMenu.getBoundingClientRect();
                    
                    const topMargin = 10; 
        
                    if (menuRect.top < topMargin) {
                        dropdownMenu.style.top = '100%';
                        dropdownMenu.style.bottom = 'auto';
                        dropdownMenu.style.marginTop = '8px';
                        dropdownMenu.style.marginBottom = '0';
                    }
                    const closeOnClickOutside = (event) => {
                        if (!dropdownMenu.contains(event.target) && !moreOptionsBtn.contains(event.target)) {
                            dropdownMenu.classList.add('hidden');
                            document.removeEventListener('click', closeOnClickOutside, { capture: true });
                        }
                    };
                    setTimeout(() => {
                        document.addEventListener('click', closeOnClickOutside, { capture: true });
                    }, 0);
                }
            });
        
            actionsContainer.appendChild(moreOptionsBtn);
            actionsContainer.appendChild(dropdownMenu);
            actionsOuterContainer.appendChild(actionsContainer);
            const leftActionsContainer = document.createElement('div');
            leftActionsContainer.className = 'absolute bottom-1 left-2 flex items-center bg-bg-element p-1 rounded-md opacity-0 group-hover:opacity-100 transition-opacity z-10';
            const fullscreenButton = document.createElement('button');
            fullscreenButton.className = 'p-1 text-text-secondary hover:text-accent transition-colors';
            fullscreenButton.title = 'Открыть в полном окне';
            fullscreenButton.innerHTML = `<i data-lucide="maximize" class="w-4 h-4"></i>`;
            fullscreenButton.addEventListener('click', () => { showFullscreenMessage(msg.content); });
            leftActionsContainer.appendChild(fullscreenButton);
            
            messageWrapper.appendChild(headerDiv);
            messageWrapper.appendChild(contentDiv);
            messageWrapper.appendChild(actionsOuterContainer);
            messageWrapper.appendChild(leftActionsContainer);
        
            if (leftActionsContainer && contentDiv && !isUser) {
                const isComplex = /<think>|<pipeline_trace>/.test(contentAsString);
            
                if (!isComplex) {
                    const speakControlsContainer = document.createElement('div');
                    speakControlsContainer.className = 'speak-controls-container relative';
            
                    speakControlsContainer.innerHTML = `
                        <button class="speak-message-btn p-1 text-text-secondary hover:text-accent transition-colors" title="Озвучить сообщение">
                            <i data-lucide="volume-2" class="w-4 h-4"></i>
                        </button>
                        <div class="voice-selection-dropdown hidden absolute bottom-full mb-2 left-0 w-56 bg-bg-sidebar border border-border-color rounded-lg shadow-xl z-20 max-h-60 overflow-y-auto">
                            <!-- Голоса будут добавлены сюда через JS -->
                        </div>
                    `;
                    leftActionsContainer.appendChild(speakControlsContainer);
                }
            }
        
            messageWrapper.querySelectorAll('pre').forEach((preElement) => {
                 const codeBlock = preElement.querySelector('code');
                 if (!codeBlock) return;
                 
                 if (codeBlock.classList.contains('language-mermaid') && !preElement.closest('.diagram-wrapper')) {
                    const diagramWrapper = document.createElement('div');
                    diagramWrapper.className = 'diagram-wrapper';
                    
                    const codeToShow = preElement.cloneNode(true);
                    const diagramContainer = document.createElement('div');
                    diagramContainer.className = 'mermaid-render-container hidden';
        
                    const buttonsContainer = document.createElement('div');
                    buttonsContainer.className = 'diagram-actions-container';
        
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'code-action-btn';
                    copyBtn.title = 'Копировать код диаграммы';
                    copyBtn.innerHTML = '<i data-lucide="copy" class="w-4 h-4"></i>';
                    copyBtn.addEventListener('click', () => {
                         navigator.clipboard.writeText(codeBlock.innerText);
                         copyBtn.innerHTML = '<i data-lucide="check" class="w-4 h-4 text-green-400"></i>';
                         setTimeout(() => { copyBtn.innerHTML = '<i data-lucide="copy" class="w-4 h-4"></i>'; lucide.createIcons(); }, 2000);
                         lucide.createIcons();
                    });
        
                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = 'code-action-btn';
                    toggleBtn.title = 'Показать/скрыть диаграмму';
                    toggleBtn.innerHTML = '<i data-lucide="git-fork" class="w-4 h-4"></i>';
                    
                    buttonsContainer.appendChild(copyBtn);
                    buttonsContainer.appendChild(toggleBtn);
                    
                    diagramWrapper.appendChild(codeToShow);
                    diagramWrapper.appendChild(diagramContainer);
                    diagramWrapper.appendChild(buttonsContainer);
                    
                    preElement.replaceWith(diagramWrapper);
        
                    (async () => {
                        try {
                            await mermaid.parse(codeBlock.innerText);
                            toggleBtn.click();
                        } catch (e) {
                            console.warn('Mermaid syntax error found, not auto-rendering:', e.str || e.message);
                            toggleBtn.disabled = true;
                            toggleBtn.title = 'Невозможно отобразить: ошибка синтаксиса';
                            const icon = toggleBtn.querySelector('i');
                            icon.setAttribute('data-lucide', 'alert-circle');
                            icon.classList.add('text-red-400');
                            lucide.createIcons({nodes: [toggleBtn]});
                        }
                    })();
        
                    toggleBtn.addEventListener('click', async () => {
                        if (diagramContainer.querySelector('.text-red-400')) return;
        
                        const isDiagramCurrentlyHidden = diagramContainer.classList.contains('hidden');
                        
                        if (isDiagramCurrentlyHidden && diagramContainer.innerHTML === '') {
                            diagramContainer.innerHTML = '<div class="flex justify-center items-center p-4"><div class="typing-indicator"><span></span><span></span><span></span></div></div>';
                            try {
                                const { svg } = await mermaid.render('msg-mermaid-' + Date.now(), codeBlock.innerText);
                                diagramContainer.innerHTML = svg;
                            } catch (err) {
                                diagramContainer.innerHTML = `<div class="text-red-400 p-4 text-center"><b>Ошибка синтаксиса Mermaid</b><pre class="mt-2 text-xs text-left">${err.str || err.message}</pre></div>`;
                                return;
                            }
                        }
                        
                        diagramContainer.classList.toggle('hidden');
                        codeToShow.classList.toggle('hidden');
                        toggleBtn.querySelector('i').setAttribute('data-lucide', diagramContainer.classList.contains('hidden') ? 'git-fork' : 'code');
                        lucide.createIcons({nodes: [toggleBtn]});
                    });
                 } else if (!preElement.querySelector('.copy-code-btn')) {
                     const buttonContainer = document.createElement('div');
                     buttonContainer.className = 'code-block-actions';
                     const copyBtn = document.createElement('button');
                     copyBtn.className = 'code-action-btn copy-code-btn';
                     copyBtn.title = "Копировать код";
                     copyBtn.innerHTML = '<i data-lucide="copy" class="w-4 h-4"></i>';
                     copyBtn.addEventListener('click', () => {
                         navigator.clipboard.writeText(codeBlock.innerText);
                         copyBtn.innerHTML = '<i data-lucide="check" class="w-4 h-4 text-green-400"></i>';
                         setTimeout(() => { copyBtn.innerHTML = '<i data-lucide="copy" class="w-4 h-4"></i>'; lucide.createIcons(); }, 2000);
                         lucide.createIcons();
                     });
                     buttonContainer.appendChild(copyBtn);
                     preElement.appendChild(buttonContainer);
                 }
                 hljs.highlightElement(codeBlock);
            });
        
            lucide.createIcons({ attrs: { 'stroke-width': 1.5 }, nodes: [messageWrapper] });
            return messageWrapper;
        }
        
        function renderChatMessages(session) {
            const messagesContainer = document.getElementById('chat-messages');
            if (!messagesContainer) return;

            const isScrolledToBottom = messagesContainer.scrollHeight - messagesContainer.clientHeight <= messagesContainer.scrollTop + 5;

            const newMessages = session.messages || [];
            const existingMessageElements = messagesContainer.querySelectorAll('.message-container');

            newMessages.forEach((msg, index) => {
                const existingEl = existingMessageElements[index];

                if (existingEl) {

                    const oldContent = existingEl.dataset.content;
                    if (oldContent !== msg.content) {

                        const newElement = createMessageElement(msg, index);
                        newElement.dataset.content = msg.content;
                        existingEl.replaceWith(newElement);
                    }
                } else {

                    const newElement = createMessageElement(msg, index);
                    newElement.dataset.content = msg.content;
                    messagesContainer.appendChild(newElement);
                }
            });

            if (existingMessageElements.length > newMessages.length) {
                for (let i = newMessages.length; i < existingMessageElements.length; i++) {
                    existingMessageElements[i].remove();
                }
            }
            
            if (isScrolledToBottom) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }
        
        function renderRoles() {
            const list = document.getElementById('roles-list');
            if (!list) return;
            if (state.roles.length === 0) {
                list.innerHTML = `<p class="text-text-secondary md:col-span-2 xl:col-span-3 text-center py-10">Нет добавленных ролей. Нажмите "Добавить роль", чтобы создать новую.</p>`;
                return;
            }
            list.innerHTML = state.roles.map(r => `
                <div class="bg-bg-sidebar rounded-lg border border-border-color p-4 flex flex-col justify-between h-full transition-shadow hover:shadow-lg hover:border-accent/50">
                    <div>
                        <div class="flex justify-between items-start mb-2">
                            <h3 class="font-bold text-lg pr-2">${r.name}</h3>
                            <div class="flex items-center space-x-1 flex-shrink-0">
                                <button class="edit-role-btn p-1.5 text-text-secondary hover:text-accent transition-colors" data-id="${r.id}"><i data-lucide="edit" class="w-4 h-4"></i></button>
                                <button class="delete-role-btn p-1.5 text-text-secondary hover:text-red-400 transition-colors" data-id="${r.id}"><i data-lucide="trash-2" class="w-4 h-4"></i></button>
                            </div>
                        </div>
                        <p class="text-sm text-text-secondary bg-bg-input p-3 rounded-md line-clamp-3">${r.content}</p>
                    </div>
                </div>
            `).join('');
            lucide.createIcons();
        }
        
        function getSettingsViewHTML() {
            return `<div class="p-4 sm:p-6 space-y-4">
                <!-- Аккордеон для Персонализации -->
                <details class="bg-bg-sidebar rounded-lg border border-border-color transition-shadow hover:shadow-lg">
                    <summary class="p-4 cursor-pointer font-bold text-xl flex justify-between items-center hover:bg-bg-element rounded-t-lg">
                        <span class="flex items-center"><i data-lucide="palette" class="w-6 h-6 mr-3 text-accent"></i>Персонализация</span>
                        <i data-lucide="chevron-down" class="w-5 h-5 transition-transform details-arrow"></i>
                    </summary>
                    <div class="p-4 border-t border-border-color space-y-6">
                        <div>
                            <label for="accent-color-picker" class="font-semibold text-text-primary block mb-2">Акцентный цвет</label>
                            <p class="text-sm text-text-secondary mb-3">Этот цвет будет использоваться для кнопок, иконок и легкого окрашивания фона интерфейса.</p>
                            <div class="flex items-center gap-4">
                                <input type="text" id="accent-color-picker" value="#409eff">
                                <button id="reset-color-btn" class="px-4 py-2 rounded-md bg-bg-input hover:bg-gray-600 transition-colors text-sm">Сбросить</button>
                            </div>
                        </div>

                        <!-- === СЛАЙДЕР ЯРКОСТИ === -->
                        <div>
                            <label for="accent-brightness-slider" class="font-semibold text-text-primary block mb-2">Яркость кнопок и акцентов</label>
                            <p class="text-sm text-text-secondary mb-3">Если выбран тёмный цвет, увеличьте яркость для лучшего контраста.</p>
                            <div class="flex items-center gap-4">
                               <input type="range" id="accent-brightness-slider" min="0" max="50" step="1" class="w-full h-2 bg-bg-input rounded-lg appearance-none cursor-pointer">
                               <span id="brightness-value-display" class="font-mono text-sm text-text-secondary w-12 text-center">20%</span>
                            </div>
                        </div>
                    </div>
                </details>

                <!-- Аккордеон для Провайдеров -->
                <details class="bg-bg-sidebar rounded-lg border border-border-color transition-shadow hover:shadow-lg">
                    <summary class="p-4 cursor-pointer font-bold text-xl flex justify-between items-center hover:bg-bg-element rounded-t-lg">
                        <span class="flex items-center"><i data-lucide="server" class="w-6 h-6 mr-3 text-accent"></i>Провайдеры API</span>
                        <i data-lucide="chevron-down" class="w-5 h-5 transition-transform details-arrow"></i>
                    </summary>
                    <div class="p-4 border-t border-border-color">
                        <div class="flex justify-end mb-6">
                            <button id="add-new-provider-btn" class="flex items-center px-4 py-2 bg-accent hover:bg-accent-hover rounded-md transition-colors flex-shrink-0">
                                <i data-lucide="plus" class="w-5 h-5 mr-2"></i>
                                Добавить провайдера
                            </button>
                        </div>
                        <div id="providers-list" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
                        </div>
                    </div>
                </details>
        
                <!-- Аккордеон для Ролей -->
                <details class="bg-bg-sidebar rounded-lg border border-border-color transition-shadow hover:shadow-lg">
                    <summary class="p-4 cursor-pointer font-bold text-xl flex justify-between items-center hover:bg-bg-element rounded-t-lg">
                        <span class="flex items-center"><i data-lucide="user-cog" class="w-6 h-6 mr-3 text-accent"></i>Управление ролями</span>
                        <i data-lucide="chevron-down" class="w-5 h-5 transition-transform details-arrow"></i>
                    </summary>
                    <div class="p-4 border-t border-border-color">
                        <div class="flex justify-end mb-6">
                            <button id="add-new-role-btn" class="flex items-center px-4 py-2 bg-accent hover:bg-accent-hover rounded-md transition-colors flex-shrink-0">
                                <i data-lucide="plus" class="w-5 h-5 mr-2"></i>
                                Добавить роль
                            </button>
                        </div>
                        <div id="roles-list" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
                        </div>
                    </div>
                </details>

                <!-- Аккордеон для Пайплайнов -->
                <details class="bg-bg-sidebar rounded-lg border border-border-color transition-shadow hover:shadow-lg">
                    <summary class="p-4 cursor-pointer font-bold text-xl flex justify-between items-center hover:bg-bg-element rounded-t-lg">
                        <span class="flex items-center"><i data-lucide="route" class="w-6 h-6 mr-3 text-accent"></i>Конструктор пайплайнов</span>
                        <i data-lucide="chevron-down" class="w-5 h-5 transition-transform details-arrow"></i>
                    </summary>
                    <div class="p-4 border-t border-border-color">
                        <div class="flex justify-end mb-6">
                            <button id="add-new-pipeline-btn" class="flex items-center px-4 py-2 bg-accent hover:bg-accent-hover rounded-md transition-colors flex-shrink-0">
                                <i data-lucide="plus" class="w-5 h-5 mr-2"></i>
                                Создать пайплайн
                            </button>
                        </div>
                        <div id="pipelines-list" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
                           <!-- Здесь будут отображаться карточки пайплайнов -->
                        </div>
                    </div>
                </details>
            </div>`;
        }
    
        function renderProviders() { 
            const list = document.getElementById('providers-list'); 
            if (!list) return; 
            if (state.providers.length === 0) { 
                list.innerHTML = `<p class="text-text-secondary md:col-span-2 xl:col-span-3 text-center py-10">Нет добавленных провайдеров. Нажмите "Добавить провайдера", чтобы создать нового.</p>`; 
                return; 
            } 
            list.innerHTML = state.providers.map(p => {
                const keyCount = (p.apiKeys && p.apiKeys.length) > 0 ? p.apiKeys.length : 0;
                const models = p.models || (p.model ? [p.model] : []);
                const modelCount = models.length;

                return `
                <div class="bg-bg-sidebar rounded-lg border border-border-color p-4 flex flex-col justify-between h-full transition-shadow hover:shadow-lg hover:border-accent/50">
                    <div>
                        <div class="flex justify-between items-start mb-3">
                             <h3 class="font-bold text-lg pr-2">${p.name}</h3>
                             <div class="flex items-center space-x-1 flex-shrink-0">
                                <button class="edit-provider-btn p-1.5 text-text-secondary hover:text-accent transition-colors" data-id="${p.id}"><i data-lucide="edit" class="w-4 h-4"></i></button>
                                <button class="delete-provider-btn p-1.5 text-text-secondary hover:text-red-400 transition-colors" data-id="${p.id}"><i data-lucide="trash-2" class="w-4 h-4"></i></button>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex items-center text-text-secondary"><i data-lucide="cpu" class="w-4 h-4 mr-2 flex-shrink-0"></i><span class="font-semibold text-text-primary mr-2">Моделей:</span> ${modelCount}</div>
                            <div class="flex items-center text-text-secondary"><i data-lucide="key-round" class="w-4 h-4 mr-2 flex-shrink-0"></i><span class="font-semibold text-text-primary mr-2">Ключей:</span> ${keyCount}</div>
                            <div class="flex items-start text-text-secondary"><i data-lucide="globe" class="w-4 h-4 mr-2 mt-0.5 flex-shrink-0"></i><span class="font-semibold text-text-primary mr-2">URL:</span> <span class="break-all">${p.baseUrl}${p.path}</span></div>
                        </div>
                    </div>
                </div>
                `
            }).join(''); 
            lucide.createIcons(); 
        }
        
        function setupChatViewEventListeners() {
            const form = document.getElementById('chat-form');
            const input = document.getElementById('chat-input');
            const messagesContainer = document.getElementById('chat-messages');
            const chatViewContainer = document.getElementById('chat-view-container');
            const dropOverlay = document.getElementById('drop-overlay');
            const attachmentPreviewContainer = document.getElementById('attachment-preview-container');

            // --- Управление высотой поля ввода ---
            const MAX_VIEWPORT_HEIGHT_RATIO = 0.9;
            const adjustLayout = () => {
                if (!form || !messagesContainer || !input) return;
    
                const layoutContainer = form.parentElement;
                if (!layoutContainer) return;

                const visualViewportHeight = window.visualViewport ? window.visualViewport.height : window.innerHeight;

                const formStyle = window.getComputedStyle(form);
                const formVerticalPadding = parseFloat(formStyle.paddingTop) + parseFloat(formStyle.paddingBottom);
                const containerBasedMaxHeight = layoutContainer.offsetHeight - formVerticalPadding;

                const viewportBasedMaxHeight = visualViewportHeight * MAX_VIEWPORT_HEIGHT_RATIO;
                
                const finalMaxHeight = Math.min(containerBasedMaxHeight, viewportBasedMaxHeight);
    
                input.style.height = 'auto';
    
                if (input.scrollHeight < finalMaxHeight) {
                    input.style.height = `${input.scrollHeight}px`;
                    input.style.overflowY = 'hidden';
                } else {
                    input.style.height = `${finalMaxHeight}px`;
                    input.style.overflowY = 'auto';
                }
    
                setTimeout(() => {
                    const formHeight = form.offsetHeight;
                    messagesContainer.style.paddingBottom = `${formHeight}px`;
                }, 0);
            };

            // --- Управление прикреплением файлов ---
            const renderAttachmentPreview = () => {
                if (!attachmentPreviewContainer) return;
                if (attachedFile) {
                    attachmentPreviewContainer.innerHTML = `
                        <div class="attachment-preview bg-bg-element p-2 rounded-lg flex items-center justify-between text-sm">
                            <div class="flex items-center overflow-hidden">
                                <i data-lucide="paperclip" class="w-4 h-4 mr-2 flex-shrink-0"></i>
                                <span class="truncate font-medium">${DOMPurify.sanitize(attachedFile.name)}</span>
                            </div>
                            <button id="remove-attachment-btn" class="p-1 text-text-secondary hover:text-red-400">
                                <i data-lucide="x" class="w-4 h-4"></i>
                            </button>
                        </div>
                    `;
                    lucide.createIcons({ nodes: [attachmentPreviewContainer] });
                    document.getElementById('remove-attachment-btn').addEventListener('click', () => {
                        attachedFile = null;
                        renderAttachmentPreview();
                        adjustLayout();
                    });
                } else {
                    attachmentPreviewContainer.innerHTML = '';
                }
            };
            
            if (chatViewContainer && dropOverlay) {
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    chatViewContainer.addEventListener(eventName, e => {
                        e.preventDefault();
                        e.stopPropagation();
                    });
                });
                chatViewContainer.addEventListener('dragenter', () => dropOverlay.classList.remove('hidden'));
                dropOverlay.addEventListener('dragleave', () => dropOverlay.classList.add('hidden'));
                chatViewContainer.addEventListener('drop', (e) => {
                    dropOverlay.classList.add('hidden');
                    if (e.dataTransfer.files.length > 0) {
                        const file = e.dataTransfer.files[0];
                        const reader = new FileReader();
                        reader.onload = (readEvent) => {
                            attachedFile = { name: file.name, content: readEvent.target.result };
                            renderAttachmentPreview();
                            adjustLayout();
                        };
                        reader.onerror = () => showModalAlert('Не удалось прочитать файл.');
                        reader.readAsText(file);
                    }
                });
            }

            // --- Панель настроек чата и ее элементы ---
            const settingsToggle = document.getElementById('chat-settings-toggle');
            const settingsPanel = document.getElementById('chat-settings-panel');
            const settingsIcon = document.getElementById('chat-settings-icon');
            const widthToggleBtn = document.getElementById('chat-width-toggle');
            const titleInput = document.getElementById('chat-title-input');
            const providerSelect = document.getElementById('provider-select');
            const modelSelect = document.getElementById('model-select');
            const roleSelect = document.getElementById('role-select');
            const pipelineSelect = document.getElementById('pipeline-select'); // НОВЫЙ ЭЛЕМЕНТ
            const singleModelSettings = document.getElementById('single-model-settings'); // НОВЫЙ ЭЛЕМЕНТ
            
            if (widthToggleBtn) {
                const isExpanded = !state.isChatWidthCompact;
                widthToggleBtn.classList.toggle('active', isExpanded);
                widthToggleBtn.title = isExpanded ? "Вернуть компактный вид" : "Расширить чат на всю ширину";
                widthToggleBtn.addEventListener('click', () => {
                    state.isChatWidthCompact = !state.isChatWidthCompact;
                    const isNowExpanded = !state.isChatWidthCompact;
                    localStorage.setItem('chatViewCompact', state.isChatWidthCompact);
                    messagesContainer?.classList.toggle('chat-view-compact', state.isChatWidthCompact);
                    widthToggleBtn.classList.toggle('active', isNowExpanded);
                    widthToggleBtn.title = isNowExpanded ? "Вернуть компактный вид" : "Расширить чат на всю ширину";
                });
            }

            settingsToggle?.addEventListener('click', (e) => {
                e.stopPropagation();
                state.isSettingsPanelExpanded = !state.isSettingsPanelExpanded;
                const isVisible = state.isSettingsPanelExpanded;
                settingsPanel.classList.toggle('opacity-100', isVisible);
                settingsPanel.classList.toggle('translate-y-0', isVisible);
                settingsPanel.classList.toggle('opacity-0', !isVisible);
                settingsPanel.classList.toggle('-translate-y-4', !isVisible);
                settingsPanel.classList.toggle('pointer-events-none', !isVisible);
                settingsIcon.classList.toggle('rotate-90', isVisible);
                const closeOnOutsideClick = (event) => {
                    if (state.isSettingsPanelExpanded && settingsPanel && !settingsPanel.contains(event.target) && !settingsToggle.contains(event.target.closest('button'))) {
                        settingsToggle.click();
                    }
                };
                if (isVisible) { document.addEventListener('click', closeOnOutsideClick, { capture: true, once: true }); }
            });

            // --- Обработка отправки формы и ввода ---
            form?.addEventListener('submit', handleChatSubmit);
            input?.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && e.ctrlKey) {
                    e.preventDefault();
                    form.requestSubmit();
                }
            });

            if (input && form && messagesContainer) {
                input.addEventListener('input', adjustLayout);
                const resizeObserver = new ResizeObserver(adjustLayout);
                if(chatViewContainer) { resizeObserver.observe(chatViewContainer); }
                if (window.visualViewport) { window.visualViewport.addEventListener('resize', adjustLayout); } 
                else { window.addEventListener('resize', adjustLayout); }
                setTimeout(adjustLayout, 100);
            }

            // --- Обработка изменений в настройках чата ---
            const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
            titleInput?.addEventListener('change', (e) => updateDoc(sessionRef, { title: e.target.value }));
            roleSelect?.addEventListener('change', (e) => updateDoc(sessionRef, { roleId: e.target.value }));
            
            providerSelect?.addEventListener('change', (e) => {
                const newProviderId = e.target.value;
                const selectedProvider = state.providers.find(p => p.id === newProviderId);
                let newModelName = null;
                if (selectedProvider) {
                    const models = selectedProvider.models || [];
                    if (models.length > 0) { 
                        newModelName = models[0]; 
                        if (modelSelect) { modelSelect.innerHTML = models.map(m => `<option value="${m}">${m}</option>`).join(''); }
                    } else { 
                        if (modelSelect) { modelSelect.innerHTML = '<option disabled>Нет моделей</option>'; } 
                    }
                }
                updateDoc(sessionRef, { providerId: newProviderId, modelName: newModelName });
            });
            
            modelSelect?.addEventListener('change', (e) => updateDoc(sessionRef, { modelName: e.target.value }));

            // --- НОВАЯ ЛОГИКА: ОБРАБОТКА ВЫБОРА ПАЙПЛАЙНА ---
            pipelineSelect?.addEventListener('change', (e) => {
                const newPipelineId = e.target.value;
                const isPipelineMode = !!newPipelineId;

                // Обновляем состояние в Firestore
                updateDoc(sessionRef, { pipelineId: newPipelineId || deleteField() });

                // Обновляем интерфейс настроек
                if (singleModelSettings) {
                    singleModelSettings.classList.toggle('opacity-50', isPipelineMode);
                    singleModelSettings.classList.toggle('pointer-events-none', isPipelineMode);
                    
                    singleModelSettings.querySelectorAll('select').forEach(sel => {
                        sel.disabled = isPipelineMode;
                    });
                }
            });
        }
        
        function setupNotepadViewEventListeners() {
            const titleInput = document.getElementById('note-title-input');
            const cardsGrid = document.getElementById('note-cards-grid');
            const addNewCardBtn = document.getElementById('add-new-card-btn');
            const widthToggleBtn = document.getElementById('notepad-width-toggle');
            const scrollContainer = document.getElementById('notepad-scroll-container');

            const settingsToggle = document.getElementById('notepad-settings-toggle');
            const settingsPanel = document.getElementById('notepad-settings-panel');
            const settingsIcon = document.getElementById('notepad-settings-icon');

            settingsToggle?.addEventListener('click', (e) => {
                e.stopPropagation();
                state.isNotepadSettingsPanelExpanded = !state.isNotepadSettingsPanelExpanded;
                
                const isVisible = state.isNotepadSettingsPanelExpanded;
                settingsPanel.classList.toggle('opacity-100', isVisible);
                settingsPanel.classList.toggle('translate-y-0', isVisible);
                settingsPanel.classList.toggle('opacity-0', !isVisible);
                settingsPanel.classList.toggle('-translate-y-4', !isVisible);
                settingsPanel.classList.toggle('pointer-events-none', !isVisible);
                settingsIcon.classList.toggle('rotate-90', isVisible);

                const closeOnOutsideClick = (event) => {
                    if (state.isNotepadSettingsPanelExpanded && settingsPanel && !settingsPanel.contains(event.target) && !settingsToggle.contains(event.target.closest('button'))) {
                        settingsToggle.click();
                    }
                };

                if (isVisible) {
                    document.addEventListener('click', closeOnOutsideClick, { capture: true, once: true });
                }
            });

            if(widthToggleBtn && scrollContainer) {
                const isExpanded = !state.isNotepadWidthCompact;
                widthToggleBtn.classList.toggle('active', isExpanded);
                widthToggleBtn.title = isExpanded ? "Вернуть компактный вид" : "Расширить на всю ширину";
        
                widthToggleBtn.addEventListener('click', () => {
                    state.isNotepadWidthCompact = !state.isNotepadWidthCompact;
                    const isNowExpanded = !state.isNotepadWidthCompact;
        
                    localStorage.setItem('notepadViewCompact', String(state.isNotepadWidthCompact));
        
                    scrollContainer.classList.toggle('notepad-view-compact', state.isNotepadWidthCompact);
                    widthToggleBtn.classList.toggle('active', isNowExpanded);
        
                    widthToggleBtn.title = isNowExpanded ? "Вернуть компактный вид" : "Расширить на всю ширину";
                });
            }
            
            const debounce = (func, delay) => {
                let timeoutId;
                return (...args) => {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => {
                        func.apply(this, args);
                    }, delay);
                };
            };
            
            const saveCardData = async (cardId) => {
                if (!state.activeSessionId) return;
                const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);

                const cardEl = cardsGrid.querySelector(`.note-card[data-card-id="${cardId}"]`);
                if (!cardEl) return;
        
                const activeSession = state.sessions.find(s => s.id === state.activeSessionId);
                if (!activeSession || !activeSession.cards) return;
        
                const newTitle = cardEl.querySelector('.note-card-title').value;
                const newContent = cardEl.querySelector('.note-card-content').value;
        
                const originalCard = activeSession.cards.find(c => c.id === cardId);
                
                if (originalCard && (originalCard.title !== newTitle || originalCard.content !== newContent)) {
                    const updatedCards = activeSession.cards.map(card => 
                        card.id === cardId ? { ...card, title: newTitle, content: newContent } : card
                    );
                    await updateDoc(sessionRef, { cards: updatedCards, updatedAt: serverTimestamp() });
                }
            };
            
            const debouncedSave = debounce(saveCardData, 750);
            
            function autoResizeTextarea(textarea) {
                if (!textarea) return;
                textarea.style.height = 'auto';
                textarea.style.height = (textarea.scrollHeight) + 'px';
            }

            titleInput?.addEventListener('change', () => {
                if (!state.activeSessionId) return;
                const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
                updateDoc(sessionRef, { title: titleInput.value, updatedAt: serverTimestamp() });
            });
        
            addNewCardBtn?.addEventListener('click', async () => {
                if (!state.activeSessionId) return;
                const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);

                const newCard = {
                    id: 'card_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9),
                    title: '',
                    content: '',
                    createdAt: new Date().toISOString()
                };
                
                await updateDoc(sessionRef, {
                    cards: arrayUnion(newCard),
                    updatedAt: serverTimestamp()
                });
            });
            
            cardsGrid?.addEventListener('focusout', (e) => {
                const cardEl = e.target.closest('.note-card');
                if (cardEl && e.target.matches('.note-card-title, .note-card-content')) {
                    saveCardData(cardEl.dataset.cardId);
                }
            });
        
            cardsGrid?.addEventListener('click', (e) => {
                const deleteBtn = e.target.closest('.note-card-delete-btn');
                if (!deleteBtn) return;
                
                createInlineConfirmation(deleteBtn, async () => {
                    const cardEl = deleteBtn.closest('.note-card');
                    const cardId = cardEl.dataset.cardId;
                    if (!state.activeSessionId) return;
                    const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
                    const activeSession = state.sessions.find(s => s.id === state.activeSessionId);
                    const cardToDelete = (activeSession.cards || []).find(c => c.id === cardId);
            
                    if (cardToDelete) {
                        await updateDoc(sessionRef, {
                            cards: arrayRemove(cardToDelete),
                            updatedAt: serverTimestamp()
                        });
                    }
                });
            });
            
            cardsGrid?.addEventListener('input', (e) => {
                if (!e.target) return;
                const cardEl = e.target.closest('.note-card');
                
                if (e.target.matches('.note-card-content')) {
                    autoResizeTextarea(e.target);
                }
                
                if (cardEl && e.target.matches('.note-card-title, .note-card-content')) {
                    debouncedSave(cardEl.dataset.cardId);
                }
            });

            setTimeout(() => {
                const allTextareas = cardsGrid?.querySelectorAll('.note-card-content');
                allTextareas?.forEach(autoResizeTextarea);
            }, 0);

            lucide.createIcons();
        }

        function setupDiagramsViewEventListeners() {
            const titleInput = document.getElementById('diagram-title-input');
            const codeInput = document.getElementById('diagram-input');
            const output = document.getElementById('diagram-output');
            const errorContainer = document.getElementById('diagram-error-container');
            const previewPanel = document.getElementById('diagram-preview-panel');
        
            const storageKey = 'diagramSplitterSizes';
            let splitInstance = null;
            let panzoomInstance = null;
        
            function initializeSplitter() {
                if (splitInstance) {
                    splitInstance.destroy();
                }
                const isMobile = window.innerWidth < 1024;
                let initialSizes = localStorage.getItem(storageKey) ? JSON.parse(localStorage.getItem(storageKey)) : [50, 50];
                splitInstance = Split(['#diagram-code-panel', '#diagram-preview-panel'], {
                    sizes: initialSizes,
                    minSize: 0,
                    gutterSize: isMobile ? 20 : 10, // *** ИЗМЕНЕНИЕ: Увеличенная область для мобильных ***
                    direction: isMobile ? 'vertical' : 'horizontal',
                    cursor: isMobile ? 'row-resize' : 'col-resize',
                    onDragEnd: function(sizes) {
                        localStorage.setItem(storageKey, JSON.stringify(sizes));
                    }
                });
            }
        
            initializeSplitter();
        
            const resetZoomBtn = document.createElement('button');
            resetZoomBtn.innerHTML = '<i data-lucide="zoom-out" class="w-4 h-4"></i>';
            resetZoomBtn.title = 'Сбросить масштаб и положение';
            resetZoomBtn.className = "absolute top-3 right-3 z-10 p-2 rounded-full bg-bg-element hover:bg-accent transition-colors";
            resetZoomBtn.addEventListener('click', () => {
                if (panzoomInstance) {
                    panzoomInstance.moveTo(0, 0);
                    panzoomInstance.zoomAbs(0, 0, 1);
                }
            });
            previewPanel.appendChild(resetZoomBtn);
            lucide.createIcons({ nodes: [resetZoomBtn] });
        
            if (typeof mermaid === 'undefined') {
                output.innerHTML = '<p class="text-red-400">Ошибка: Библиотека Mermaid.js не загружена.</p>';
                return;
            }
        
            mermaid.initialize({ startOnLoad: false, theme: 'dark', securityLevel: 'loose', fontFamily: 'Inter, sans-serif' });
        
            const renderDiagram = async () => {
                if (panzoomInstance) {
                    panzoomInstance.dispose();
                    panzoomInstance = null;
                }
        
                const diagramCode = codeInput.value.trim();
                if (!diagramCode) {
                    output.innerHTML = '<p class="text-text-secondary">Начните вводить код слева...</p>';
                    errorContainer.textContent = '';
                    resetZoomBtn.style.display = 'none';
                    return;
                }
        
                try {
                    // <-- РЕШЕНИЕ №2: Сначала парсим, чтобы перехватить ошибку ДО рендеринга
                    await mermaid.parse(diagramCode);
        
                    // Если парсинг прошел успешно, рендерим
                    const { svg, bindFunctions } = await mermaid.render('mermaid-graph-' + Date.now(), diagramCode);
                    output.innerHTML = svg;
                    if (bindFunctions) bindFunctions(output);
                    errorContainer.textContent = '';
        
                    const svgElement = output.querySelector('svg');
                    if (svgElement) {
                        svgElement.style.cursor = 'grab';
                        panzoomInstance = panzoom(svgElement, { maxZoom: 5, minZoom: 0.1 });
                        resetZoomBtn.style.display = 'block';
                    }
        
                } catch (error) {
                    // Теперь мы ловим ошибку от parse() и безопасно выводим ее
                    const errorMessage = (error.str || error.message || 'Неизвестная ошибка синтаксиса').replace(/</g, "<").replace(/>/g, ">");
                    output.innerHTML = `
                        <div class="text-center p-4 flex flex-col items-center justify-center h-full">
                            <i data-lucide="alert-triangle" class="w-16 h-16 text-red-500 mx-auto"></i>
                            <p class="mt-4 text-lg font-bold">Ошибка в коде диаграммы</p>
                            <p class="mt-1 text-sm text-text-secondary">Пожалуйста, проверьте синтаксис.</p>
                            <pre class="mt-4 text-xs text-left bg-bg-input p-2 rounded-md w-full max-w-sm overflow-auto">${errorMessage}</pre>
                        </div>`;
                    errorContainer.textContent = 'Ошибка синтаксиса';
                    resetZoomBtn.style.display = 'none';
                    lucide.createIcons({ nodes: [output] });
                }
            };
            
            const debounce = (func, delay) => {
                let timeoutId;
                return (...args) => {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => {
                        func.apply(this, args);
                    }, delay);
                };
            };
        
            const saveDiagramCode = async () => {
                if (!state.activeSessionId) return;
                const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
                await updateDoc(sessionRef, { code: codeInput.value, updatedAt: serverTimestamp() });
            };
        
            const debouncedSave = debounce(saveDiagramCode, 750);
            const debouncedRender = debounce(renderDiagram, 300);
        
            titleInput.addEventListener('change', async () => {
                if (!state.activeSessionId) return;
                const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
                await updateDoc(sessionRef, { title: titleInput.value, updatedAt: serverTimestamp() });
            });
            
            codeInput.addEventListener('input', () => {
                debouncedSave();
                debouncedRender();
            });
        
            renderDiagram();
        }
    
        function setupSettingsViewEventListeners() {
            document.getElementById('add-new-provider-btn')?.addEventListener('click', handleAddProvider);
            document.getElementById('add-new-role-btn')?.addEventListener('click', handleAddRole);

            // Инициализируем Coloris для нашего элемента
            if (document.getElementById('accent-color-picker')) {
                Coloris({
                    el: '#accent-color-picker',
                    themeMode: 'dark',
                    theme: 'large',
                    alpha: false,
                    swatches: ['#409eff', '#26d07c', '#ff4d4d', '#f7d351', '#8e44ad', '#ffffff']
                });
            }

            const colorPicker = document.getElementById('accent-color-picker');
            const resetColorBtn = document.getElementById('reset-color-btn');
            const brightnessSlider = document.getElementById('accent-brightness-slider');
            const brightnessDisplay = document.getElementById('brightness-value-display');

            const DEFAULT_ACCENT_RGB = '0, 0, 0'; // Стандартный синий
            const DEFAULT_BRIGHTNESS = '20';

            if (colorPicker) {
                const savedAccentRGB = localStorage.getItem('userAccentRGB') || DEFAULT_ACCENT_RGB;
                colorPicker.value = rgbStringToHex(savedAccentRGB);

                colorPicker.dispatchEvent(new Event('input', { bubbles: true }));

                colorPicker.addEventListener('change', (event) => {
                    const newRgbString = hexToRgbString(event.target.value);
                    document.documentElement.style.setProperty('--user-accent-rgb', newRgbString);
                    localStorage.setItem('userAccentRGB', newRgbString);
                });
            }

            if (brightnessSlider && brightnessDisplay) {
                const currentBrightness = (localStorage.getItem('userAccentBrightness') || DEFAULT_BRIGHTNESS);
                brightnessSlider.value = currentBrightness;
                brightnessDisplay.textContent = `${currentBrightness}%`;

                brightnessSlider.addEventListener('input', (event) => {
                    const newBrightness = event.target.value;
                    document.documentElement.style.setProperty('--accent-brightness-strength', `${newBrightness}%`);
                    brightnessDisplay.textContent = `${newBrightness}%`;
                    localStorage.setItem('userAccentBrightness', newBrightness);
                });
            }

            if (resetColorBtn) {
                resetColorBtn.addEventListener('click', () => {
                    document.documentElement.style.setProperty('--user-accent-rgb', DEFAULT_ACCENT_RGB);
                    localStorage.setItem('userAccentRGB', DEFAULT_ACCENT_RGB);
                    
                    if (colorPicker) {
                        colorPicker.value = rgbStringToHex(DEFAULT_ACCENT_RGB);
                        colorPicker.dispatchEvent(new Event('input', { bubbles: true }));
                    }

                    document.documentElement.style.setProperty('--accent-brightness-strength', `${DEFAULT_BRIGHTNESS}%`);
                    localStorage.setItem('userAccentBrightness', DEFAULT_BRIGHTNESS);
                    if (brightnessSlider) brightnessSlider.value = DEFAULT_BRIGHTNESS;
                    if (brightnessDisplay) brightnessDisplay.textContent = `${DEFAULT_BRIGHTNESS}%`;
                });
            }
        }
        
        async function handleChatSubmit(e) {
            e.preventDefault();
            const input = document.getElementById('chat-input');
            const messageContent = input.value.trim();
            
            if ((!messageContent && !attachedFile) || state.loadingSessionId) return;

            const activeSession = state.sessions.find(s => s.id === state.activeSessionId);
            const provider = state.providers.find(p => p.id === activeSession.providerId);
            const selectedRole = state.roles.find(r => r.id === activeSession.roleId);

            const messagesToSubmit = [...(activeSession.messages || [])];

            if (attachedFile) {
                const fileMessageContent = `<file name="${attachedFile.name}">\n${attachedFile.content}\n</file>`;
                const fileMessage = { role: 'user', content: fileMessageContent };
                messagesToSubmit.push(fileMessage);
            }

            if (messageContent) {
                 const userMessage = { role: 'user', content: messageContent };
                 messagesToSubmit.push(userMessage);
            }
            
            input.value = '';
            // Триггерим событие input, чтобы ваша функция adjustLayout сбросила высоту поля
            input.dispatchEvent(new Event('input', { bubbles: true }));
            
            if (attachedFile) {
                attachedFile = null;
                // Удаляем предпросмотр и снова вызываем adjustLayout
                document.getElementById('attachment-preview-container').innerHTML = '';
                input.dispatchEvent(new Event('input', { bubbles: true }));
            }

            const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
            await updateDoc(sessionRef, { messages: messagesToSubmit, updatedAt: serverTimestamp() });

            await generateAssistantResponse(
                state.activeSessionId,
                messagesToSubmit,
                provider,
                selectedRole,
                activeSession.modelName
            );
        }

        function parseThinkContent(rawContent) {
            if (typeof rawContent !== 'string') {
                return { thought: null, clean: '' };
            }
        
            const thinkRegex = /<think>([\s\S]*?)<\/think>/;
            const match = rawContent.match(thinkRegex);
        
            if (match) {
                // match[0] - это весь тег с содержимым, например, "<think>...</think>"
                // match[1] - это только содержимое внутри тега
                const thoughtContent = match[1].trim();
                const cleanContent = rawContent.replace(thinkRegex, '').trim();
                return { thought: thoughtContent, clean: cleanContent };
            } else {
                // Если тега <think> нет, весь контент считается чистым.
                return { thought: null, clean: rawContent.trim() };
            }
        }
        
        async function generateAssistantResponse(sessionId, messagesToSubmit, provider, selectedRole, modelName) {
            if (state.loadingSessionId) return;
        
            generationAbortController = new AbortController();
            const signal = generationAbortController.signal;
        
            state.loadingSessionId = sessionId;
            render(); 
        
            let isSuccess = false;
            let wasAborted = false;
            let lastError = 'Неизвестная ошибка.';
            
            const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, sessionId);
            let currentMessages = [...messagesToSubmit];
        
            const getCleanContent = (rawContent) => {
                if (typeof rawContent !== 'string') return '';
                const thinkRegex = /<think>[\s\S]*?<\/think>/g;
                return rawContent.replace(thinkRegex, '').trim();
            };
        
            try {
                const initialActiveSession = state.sessions.find(s => s.id === sessionId);
                const selectedPipeline = initialActiveSession?.pipelineId ? state.pipelines.find(p => p.id === initialActiveSession.pipelineId) : null;
        
                if (selectedPipeline && selectedPipeline.steps && selectedPipeline.steps.length > 0) {
                    // --- ЛОГИКА ПАЙПЛАЙНА ---
                    let pipelineTraceLog = `**Начало выполнения пайплайна: "${selectedPipeline.name}"**\n\n`;
                    let lastStepOutput = getCleanContent(currentMessages.findLast(m => m.role === 'user')?.content || '');

                    const assistantMessage = { 
                        role: 'assistant', 
                        content: '*Инициализация пайплайна...*', 
                        modelName: selectedPipeline.name + " (Пайплайн)",
                        pipelineTrace: pipelineTraceLog
                    };
                    currentMessages.push(assistantMessage);
                    await updateDoc(sessionRef, { messages: currentMessages, updatedAt: serverTimestamp() });
        
                    for (let i = 0; i < selectedPipeline.steps.length; i++) {
                        if (signal.aborted) throw new Error('AbortError');
        
                        const step = selectedPipeline.steps[i];
                        const stepProvider = state.providers.find(p => p.id === step.providerId);
                        const stepModelName = step.modelName;
        
                        if (!stepProvider || !stepModelName) throw new Error(`Ошибка на шаге ${i + 1}: провайдер или модель не найдены.`);
                        if (!lastStepOutput) throw new Error(`Шаг ${i + 1} (${stepModelName}) получил пустые входные данные. Пайплайн прерван.`);

                        // *** КЛЮЧЕВОЕ ИСПРАВЛЕНИЕ: Собираем ОДИН промпт из роли и данных ***
                        const stepInstruction = step.roleContent || ''; // Роль/инструкция для этого шага
                        let finalApiContent;

                        if (stepInstruction) {
                            // Если есть инструкция, формируем полный промпт
                            finalApiContent = `${stepInstruction}\n\n---\n\nВот данные, которые нужно обработать:\n\n${lastStepOutput}`;
                        } else {
                            // Если инструкции нет, просто передаем данные
                            finalApiContent = lastStepOutput;
                        }
                        
                        pipelineTraceLog += `---  \n**Шаг ${i + 1}/${selectedPipeline.steps.length}:** Модель \`${stepModelName}\`  \n`;
                        pipelineTraceLog += `**Входные данные (для API):**\n\`\`\`\n${finalApiContent}\n\`\`\`\n*Выполняется...*\n`;
                        
                        const lastMessage = currentMessages.at(-1);
                        lastMessage.pipelineTrace = pipelineTraceLog;
                        lastMessage.content = `*Выполняется шаг ${i + 1}: ${stepModelName}...*`;
                        
                        await updateDoc(sessionRef, { messages: currentMessages, updatedAt: serverTimestamp() });
                        
                        // *** ВОЗВРАЩАЕМСЯ К СТАРОЙ, РАБОЧЕЙ СТРУКТУРЕ ВЫЗОВА API ***
                        const apiMessages = [{ role: 'user', content: finalApiContent }];
                        
                        const stepResponse = await callApi(stepProvider, stepModelName, apiMessages, signal);
                        const cleanResponse = getCleanContent(stepResponse);
                        
                        pipelineTraceLog = pipelineTraceLog.replace('*Выполняется...*\n', `**Выходные данные:**\n\`\`\`\n${cleanResponse}\n\`\`\`\n\n`);
                        
                        lastMessage.content = cleanResponse; 
                        lastMessage.pipelineTrace = pipelineTraceLog;
                        
                        await updateDoc(sessionRef, { messages: currentMessages, updatedAt: serverTimestamp() });
                        
                        // Готовим выход для следующего шага
                        lastStepOutput = cleanResponse;
                    }
                    isSuccess = true;
                } else {
                    // --- ЛОГИКА ОДИНОЧНОЙ МОДЕЛИ (не тронута, работает как раньше) ---
                    if (!provider) throw new Error("Провайдер API не найден или не выбран.");
                    if (!modelName) throw new Error("Модель не выбрана.");
                    const apiMessagesPayload = [];
                    if (selectedRole?.content) apiMessagesPayload.push({ role: 'system', content: selectedRole.content });
                    
                    const cleanedHistory = currentMessages.map(msg => ({ role: msg.role, content: getCleanContent(msg.content) }));
                    apiMessagesPayload.push(...cleanedHistory.filter(msg => msg.role === 'system' || msg.content));

                    console.log("%cПОДГОТОВКА К ВЫЗОВУ API (Обычный режим):", "color: yellow; font-weight: bold;");
                    console.log("Провайдер:", provider);
                    console.log("Имя модели:", modelName);
                    console.log("Отправляемые сообщения:", JSON.parse(JSON.stringify(apiMessagesPayload))); 
                    
                    const assistantMessageContent = getCleanContent(await callApi(provider, modelName, apiMessagesPayload, signal));
                    currentMessages.push({ role: 'assistant', content: assistantMessageContent, modelName: modelName });
                    isSuccess = true;
                }
        
            } catch (error) {
                if (error.name === 'AbortError' || error.message === 'AbortError') {
                    wasAborted = true;
                    lastError = 'Генерация остановлена пользователем.';
                } else {
                    console.error("Ошибка в generateAssistantResponse:", error);
                    lastError = error.message;
                }
            } finally {
                // ... остальная часть функции без изменений
                generationAbortController = null;
                state.loadingSessionId = null;
        
                if (!isSuccess) {
                    const errorMessageContent = wasAborted 
                        ? '*Генерация была остановлена.*' 
                        : `**Ошибка:** Не удалось получить ответ.\n*Детали: ${lastError}*`;
                    
                    const lastMessage = currentMessages.at(-1);
                    if (lastMessage && lastMessage.role === 'assistant') {
                        lastMessage.content = errorMessageContent;
                    } else {
                        currentMessages.push({ role: 'assistant', content: errorMessageContent, modelName: 'Ошибка' });
                    }
                }
        
                await updateDoc(sessionRef, { messages: currentMessages, updatedAt: serverTimestamp() });
                
                render(); 
        
                if (isSuccess && (document.hidden || state.activeSessionId !== sessionId || state.activeTab !== 'chat')) {
                    const finalSessionForNotif = state.sessions.find(s => s.id === sessionId);
                    const chatTitle = finalSessionForNotif?.title || 'Новый чат';
                    const messagePreview = (currentMessages.at(-1)?.content || '').substring(0, 100);
                    showInAppNotification(`Новый ответ в чате "${chatTitle}"`, messagePreview, sessionId);
                }
            }
        }
        
        function parseApiResponseContent(content) {
            if (typeof content === 'string') {
                return content;
            }
        
            if (Array.isArray(content)) {
                return content
                    .map(part => {
                        if (part && typeof part.text === 'string') {
                            return part.text;
                        }
                        return '';
                    })
                    .join('\n');
            }
            return '';
        }
        
        // Вспомогательная функция для вызова API, чтобы избежать дублирования кода
        async function callApi(provider, modelName, messages, signal) {
            const apiKeys = provider.apiKeys || [];
            if (apiKeys.length === 0) throw new Error(`У провайдера "${provider.name}" нет API ключей.`);
            const currentKey = apiKeys[0];
        
            try {
                const fullUrl = new URL(provider.path, provider.baseUrl).href;
                
                const proxyRequestBody = {
                    targetUrl: fullUrl,
                    apiKey: currentKey,
                    payload: { model: modelName, messages: messages }
                };
        
                const response = await fetch('/api/proxy', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(proxyRequestBody),
                    signal: signal
                });
        
                const rawTextResponse = await response.text();
        
                // --- ГЛАВНОЕ ИСПРАВЛЕНИЕ ---
                // Проверяем, что ответ успешный И что тело ответа НЕ пустое и НЕ равно 'null'.
                if (!response.ok || !rawTextResponse || rawTextResponse === 'null') {
                    throw new Error(`API вернул некорректный или пустой ответ (Статус: ${response.status}). Возможно, модель временно недоступна или неверно указано ее имя.`);
                }
                
                // Теперь мы уверены, что у нас есть валидный JSON для парсинга.
                const data = JSON.parse(rawTextResponse);
        
                if (data.error) {
                    throw new Error(`Ошибка от API: ${data.error.message || JSON.stringify(data.error)}`);
                }
                if (!data.choices || data.choices.length === 0 || !data.choices[0].message) {
                    throw new Error('Ответ от API не содержит ожидаемых данных (`choices`).');
                }
                
                return parseApiResponseContent(data.choices[0].message.content);
        
            } catch (error) {
                if (error.name === 'AbortError') throw error;
                console.error(`Ошибка при вызове API через прокси:`, error);
                throw new Error(error.message);
            }
        }

        function showTypingIndicatorInChat() {
            const messagesContainer = document.getElementById('chat-messages');
            if (!messagesContainer) return;
        
            // Убираем старый индикатор, если он был
            const oldIndicator = document.getElementById('loading-message-placeholder');
            if(oldIndicator) {
                if (typewriterAbortController) typewriterAbortController.abort();
                oldIndicator.remove();
            }
        
            // Запускаем новый контроллер для анимации текста
            typewriterAbortController = new AbortController();
        
            // СОЗДАЕМ КОНТЕЙНЕР С ПРАВИЛЬНЫМИ КЛАССАМИ, КАК У ОБЫЧНОГО СООБЩЕНИЯ
            const loadingMessageWrapper = document.createElement('div');
            loadingMessageWrapper.id = 'loading-message-placeholder';
            // ВОТ КЛЮЧЕВОЕ ИЗМЕНЕНИЕ: добавлены все классы от обычного сообщения
            loadingMessageWrapper.className = 'message-container group relative flex flex-col mb-6 p-4 rounded-xl assistant-message-bg items-start';
        
            // Внутренняя структура из вашего примера
            loadingMessageWrapper.innerHTML = `
                <div class="loader-content">
                    <div class="loading-avatar">
                        <i data-lucide="sparkles" class="w-4 h-4"></i>
                    </div>
                    <p id="typewriter-text"></p>
                </div>
            `;
        
            messagesContainer.appendChild(loadingMessageWrapper);
            
            lucide.createIcons({ nodes: [loadingMessageWrapper] });
            const textElement = document.getElementById('typewriter-text');
            typeWriter(textElement, typewriterAbortController.signal);
        
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function updateLoadingIndicator() {
            const form = document.getElementById('chat-form');
            if (!form) return;
        
            const button = form.querySelector('button[type="submit"], button[type="button"]');
            const textarea = form.querySelector('textarea');
            const isLoadingThisSession = state.loadingSessionId === state.activeSessionId;
        
            if (textarea) {
                textarea.disabled = isLoadingThisSession;
            }
        
            if (button) {
                const newButton = button.cloneNode(true);
                button.parentNode.replaceChild(newButton, button);
        
                if (isLoadingThisSession) {
                    newButton.setAttribute('type', 'button');
                    newButton.title = 'Остановить генерацию';
                    newButton.innerHTML = '<i data-lucide="square" class="w-5 h-5 text-white"></i>';
                    newButton.disabled = false;
        
                    const stopHandler = (e) => {
                        e.preventDefault();
                        if (generationAbortController) {
                            generationAbortController.abort();
                        }
                    };
                    newButton.addEventListener('click', stopHandler);
        
                } else {
                    newButton.setAttribute('type', 'submit');
                    newButton.title = 'Отправить';
                    newButton.innerHTML = '<i data-lucide="send" class="w-5 h-5 text-white"></i>';
                    newButton.disabled = false;
                }
                lucide.createIcons({ nodes: [newButton] });
            }
        
            const typingIndicator = document.getElementById('loading-message-placeholder');
            if (typingIndicator) {
                // Прерываем анимацию текста перед удалением элемента
                if (typewriterAbortController) {
                    typewriterAbortController.abort();
                    typewriterAbortController = null;
                }
                typingIndicator.remove();
            }
        
            if (isLoadingThisSession) {
                showTypingIndicatorInChat();
            }
        }
        
        async function handleAddProvider() {
            if (state.isLoading) return;
            state.isLoading = true;
            try {
                const newProviderData = {
                    name: 'Новый провайдер',
                    baseUrl: 'https://api.openai.com',
                    path: '/v1/chat/completions',
                    apiKeys: [],
                    models: ['gpt-4o', 'gpt-3.5-turbo'],
                    currentKeyIndex: 0
                };
                const docRef = await addDoc(collection(db, `artifacts/${appId}/users/${userId}/providers`), newProviderData);
                handleOpenEditProviderModal(docRef.id);
            } catch (error) {
                console.error("Ошибка при добавлении провайдера: ", error);
                showModalAlert("Не удалось создать провайдера.");
            } finally {
                state.isLoading = false;
            }
        }
        
        async function handleAddRole() {
            if (state.isLoading) return;
            state.isLoading = true;
            try {
                const newRoleData = {
                    name: 'Новая роль',
                    content: 'Ты — полезный ассистент.',
                    createdAt: serverTimestamp()
                };
                const docRef = await addDoc(collection(db, `artifacts/${appId}/users/${userId}/roles`), newRoleData);
                handleOpenEditRoleModal(docRef.id);
            } catch (error) {
                console.error("Ошибка при добавлении роли: ", error);
                showModalAlert("Не удалось создать роль.");
            } finally {
                state.isLoading = false;
            }
        }
        
        function handleOpenEditProviderModal(providerId) {
            const providerToEdit = state.providers.find(p => p.id === providerId);
            if (!providerToEdit) return;
            
            const apiKeysArray = providerToEdit.apiKeys || [];
            const modelsArray = providerToEdit.models || (providerToEdit.model ? [providerToEdit.model] : []);
            
            document.getElementById('edit-provider-id').value = providerToEdit.id;
            document.getElementById('edit-provider-name').value = providerToEdit.name;
            document.getElementById('edit-provider-url').value = providerToEdit.baseUrl;
            document.getElementById('edit-provider-path').value = providerToEdit.path;
            document.getElementById('edit-provider-keys').value = apiKeysArray.join('\n');
            document.getElementById('edit-provider-models').value = modelsArray.join('\n');
            
            editProviderModal.classList.remove('hidden');
        }
    
        function handleOpenEditRoleModal(roleId) {
            const roleToEdit = state.roles.find(r => r.id === roleId);
            if (!roleToEdit) return;
    
            document.getElementById('edit-role-id').value = roleToEdit.id;
            document.getElementById('edit-role-name').value = roleToEdit.name;
            document.getElementById('edit-role-content').value = roleToEdit.content;
    
            editRoleModal.classList.remove('hidden');
        }
    
        async function handleEditProviderSubmit(e) {
            e.preventDefault();
            const providerId = document.getElementById('edit-provider-id').value;
            if (!providerId) return;
    
            const name = document.getElementById('edit-provider-name').value;
            const baseUrl = document.getElementById('edit-provider-url').value;
            const path = document.getElementById('edit-provider-path').value;
            const keysRaw = document.getElementById('edit-provider-keys').value;
            const modelsRaw = document.getElementById('edit-provider-models').value;
    
            const apiKeys = keysRaw.split(/\r?\n/).map(k => k.trim()).filter(k => k.length > 0);
            if (apiKeys.length === 0) {
                showModalAlert("Пожалуйста, введите хотя бы один API ключ.");
                return;
            }
            
            const models = modelsRaw.split(/\r?\n/).map(m => m.trim()).filter(m => m.length > 0);
            if (models.length === 0) {
                showModalAlert("Пожалуйста, введите хотя бы одну модель.");
                return;
            }

            const providerRef = doc(db, `artifacts/${appId}/users/${userId}/providers`, providerId);
            const originalProvider = state.providers.find(p => p.id === providerId);
            const originalKeys = originalProvider.apiKeys || [];
            const keysChanged = JSON.stringify(originalKeys.sort()) !== JSON.stringify(apiKeys.sort());

            const updatedData = { name, baseUrl, path, apiKeys, models, model: deleteField() };
            if (keysChanged) { updatedData.currentKeyIndex = 0; }

            await updateDoc(providerRef, updatedData);
            editProviderModal.classList.add('hidden');
        }
    
        async function handleEditRoleSubmit(e) {
            e.preventDefault();
            const roleId = document.getElementById('edit-role-id').value;
            if (!roleId) return;
    
            const name = document.getElementById('edit-role-name').value;
            const content = document.getElementById('edit-role-content').value;
    
            const roleRef = doc(db, `artifacts/${appId}/users/${userId}/roles`, roleId);
            await updateDoc(roleRef, { name, content });
            editRoleModal.classList.add('hidden');
        }
    
        // function copyToClipboard(text) { navigator.clipboard.writeText(text).catch(err => console.error('Не удалось скопировать текст: ', err)); }
        // function showConfirmModal(message, onConfirm) { confirmModalText.textContent = message; confirmModalCallback = onConfirm; confirmModal.classList.remove('hidden'); }
        function hideConfirmModal() { confirmModal.classList.add('hidden'); confirmModalCallback = null; }
        function showModalAlert(message) { confirmModalText.textContent = message; confirmModalYesBtn.classList.add('hidden'); confirmModalNoBtn.textContent = 'OK'; confirmModal.classList.remove('hidden'); confirmModalCallback = () => { confirmModalYesBtn.classList.remove('hidden'); confirmModalNoBtn.textContent = 'Нет'; }; }

        function requestConfirmationInMenu(clickedElement, onConfirm) {
            const dropdownMenu = clickedElement.closest('.message-actions-dropdown');
            if (!dropdownMenu || dropdownMenu.querySelector('.inline-confirm-container')) {
                return;
            }
        
            const originalItems = Array.from(dropdownMenu.children);
            originalItems.forEach(item => item.style.display = 'none');
            
            const confirmContainer = document.createElement('div');
            confirmContainer.className = 'inline-confirm-container flex items-center justify-center space-x-2 p-2 w-full';
            confirmContainer.innerHTML = `
                <span class="text-sm font-semibold text-text-secondary">Уверены?</span>
                <button class="confirm-btn p-1.5 rounded-full text-green-400 hover:bg-green-400/20 transition-colors" title="Подтвердить">
                    <i data-lucide="check" class="w-5 h-5"></i>
                </button>
                <button class="cancel-btn p-1.5 rounded-full text-red-400 hover:bg-red-400/20 transition-colors" title="Отменить">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            `;
            dropdownMenu.appendChild(confirmContainer);
            lucide.createIcons({ nodes: [confirmContainer] });

            const cleanupAndRestore = () => {
                confirmContainer.remove();
                originalItems.forEach(item => item.style.display = ''); 
                document.removeEventListener('click', clickOutsideHandler, { capture: true });
            };

            confirmContainer.querySelector('.confirm-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                onConfirm();
                cleanupAndRestore();
            });

            confirmContainer.querySelector('.cancel-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                cleanupAndRestore();
            });

            const clickOutsideHandler = (event) => {
                if (!clickedElement.closest('.message-actions-container').contains(event.target)) {
                    cleanupAndRestore();
                }
            };
            
            setTimeout(() => {
                document.addEventListener('click', clickOutsideHandler, { capture: true });
            }, 0);
        }

        function createInlineConfirmation(clickedButton, onConfirm) {
            // Прячем оригинальную кнопку
            clickedButton.style.display = 'none';

            // Создаем контейнер для подтверждения
            const confirmContainer = document.createElement('div');
            confirmContainer.className = 'inline-confirm-container flex items-center space-x-2';
            confirmContainer.innerHTML = `
                <span class="text-sm font-semibold text-text-secondary">Уверены?</span>
                <button class="confirm-btn p-1.5 rounded-full text-green-400 hover:bg-green-400/20 transition-colors" title="Подтвердить">
                    <i data-lucide="check" class="w-5 h-5"></i>
                </button>
                <button class="cancel-btn p-1.5 rounded-full text-red-400 hover:bg-red-400/20 transition-colors" title="Отменить">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            `;
            
            // Вставляем блок подтверждения сразу после скрытой кнопки
            clickedButton.after(confirmContainer);
            lucide.createIcons({ nodes: [confirmContainer] });

            // Функция для очистки и восстановления
            const cleanupAndRestore = () => {
                confirmContainer.remove();
                clickedButton.style.display = ''; // Показываем кнопку обратно
                document.removeEventListener('click', clickOutsideHandler, { capture: true });
            };

            // Обработчики для кнопок "Да" и "Нет"
            confirmContainer.querySelector('.confirm-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                onConfirm();
                cleanupAndRestore();
            });

            confirmContainer.querySelector('.cancel-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                cleanupAndRestore();
            });

            // Обработчик для клика вне элемента для отмены
            const clickOutsideHandler = (event) => {
                if (!confirmContainer.contains(event.target)) {
                    cleanupAndRestore();
                }
            };
            
            setTimeout(() => {
                document.addEventListener('click', clickOutsideHandler, { capture: true });
            }, 0);
        }
        
        function updateSidebarView() {
            const isMobile = window.innerWidth < 1024;
            const toggleIcon = document.getElementById('sidebar-toggle-icon');
            if (isMobile) {
                sidebar.classList.remove('collapsed');
                toggleIcon.setAttribute('data-lucide', 'menu');
            } else {
                sidebar.classList.remove('open');
                sidebarBackdrop.classList.add('hidden');
                sidebar.classList.toggle('collapsed', state.isSidebarCollapsed);
                toggleIcon.setAttribute('data-lucide', state.isSidebarCollapsed ? 'panel-right-close' : 'panel-left-close');
            }
            lucide.createIcons();
        }

        function showInAppNotification(title, body, sessionId) {

            if (notificationTimeout) {
                clearTimeout(notificationTimeout);
            }

            const originalNotification = document.getElementById('in-app-notification');
            if (!originalNotification) {
                console.error("Элемент уведомления #in-app-notification не найден.");
                return;
            }

            const newNotification = originalNotification.cloneNode(true);

            const titleEl = newNotification.querySelector('#in-app-notification-title');
            const bodyEl = newNotification.querySelector('#in-app-notification-body');
            const closeBtn = newNotification.querySelector('#in-app-notification-close');

            if(titleEl) titleEl.textContent = title;
            if(bodyEl) bodyEl.textContent = body;

            const hideNotification = () => {
                newNotification.classList.add('-translate-y-[150%]', 'opacity-0');

                setTimeout(() => {
                    if(newNotification.parentNode) {
                       newNotification.classList.add('hidden');
                    }
                }, 300);
            };

            newNotification.addEventListener('click', () => {
                const session = state.sessions.find(s => s.id === sessionId);
                const targetTab = session ? session.type : 'chat';

                state.activeTab = targetTab;
                state.activeSessionId = sessionId;
                render();
                hideNotification();
            });

            if(closeBtn) {
                closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    hideNotification();
                });
            }

            originalNotification.parentNode.replaceChild(newNotification, originalNotification);
            
            lucide.createIcons({ nodes: [newNotification] });

            newNotification.classList.remove('hidden');
            
            setTimeout(() => {
                newNotification.classList.remove('-translate-y-[150%]', 'opacity-0');
            }, 0); 
        }
    
        function setupGlobalEventListeners() {
            mainNavItems.forEach(item => {
                item.addEventListener('click', () => {
                    state.activeTab = item.dataset.tab;
                    state.activeSessionId = null;
                    render();
                });
            });
        
            const createNewItem = async (type) => {
                let newSessionData;
                if (type === 'chat') {
                    let providerId = null;
                    let modelName = null;
                    if (state.providers.length > 0) {
                        const firstProvider = state.providers[0];
                        providerId = firstProvider.id;
                        const models = firstProvider.models || [];
                        if (models.length > 0) {
                            modelName = models[0];
                        }
                    }
                    newSessionData = { type: 'chat', title: 'Новый чат', messages: [], providerId, modelName, roleId: '', createdAt: serverTimestamp(), updatedAt: serverTimestamp() };
                } else if (type === 'notepad') {
                    newSessionData = {
                        type: 'notepad',
                        title: 'Новая папка',
                        cards: [],
                        createdAt: serverTimestamp(),
                        updatedAt: serverTimestamp()
                    };
                // ДОБАВЛЕН БЛОК ДЛЯ ДИАГРАММ
                } else if (type === 'diagrams') {
                    newSessionData = {
                        type: 'diagrams',
                        title: 'Новая диаграмма',
                        code: 'graph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;', // Пример кода по умолчанию
                        createdAt: serverTimestamp(),
                        updatedAt: serverTimestamp()
                    };
                }
            
                const newSessionRef = await addDoc(collection(db, `artifacts/${appId}/users/${userId}/sessions`), newSessionData);
                state.activeSessionId = newSessionRef.id;
            
                render();
                if (window.innerWidth < 1024) {
                    sidebar.classList.remove('open');
                    sidebarBackdrop.classList.remove('active');
                }
            };
        
            newChatBtn.addEventListener('click', () => createNewItem('chat'));
            newNoteBtn.addEventListener('click', () => createNewItem('notepad'));
            newDiagramBtn.addEventListener('click', () => createNewItem('diagrams'));

            // --- УПРАВЛЕНИЕ БОКОВОЙ ПАНЕЛЬЮ ---
            document.getElementById('sidebar-toggle-btn').addEventListener('click', () => {
                if (window.innerWidth < 1024) {
                    sidebar.classList.toggle('open');
                    sidebarBackdrop.classList.toggle('active');
                } else {
                    state.isSidebarCollapsed = !state.isSidebarCollapsed;
                    updateSidebarView();
                }
            });
        
            sidebarBackdrop.addEventListener('click', () => {
                sidebar.classList.remove('open');
                sidebarBackdrop.classList.remove('active');
            });
            
            window.addEventListener('resize', updateSidebarView);
        
            // --- ГЛОБАЛЬНЫЙ ОБРАБОТЧИК КЛИКОВ (ДЕЛЕГИРОВАНИЕ СОБЫТИЙ) ---
            document.body.addEventListener('click', async (e) => {
                const deleteSessionBtn = e.target.closest('.delete-session-btn');
                if (deleteSessionBtn) {
                    createInlineConfirmation(deleteSessionBtn, async () => {
                        const idToDelete = deleteSessionBtn.dataset.id;
                        await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/sessions`, idToDelete));
                    });
                    return;
                }
                
                const clearHistoryBtn = e.target.closest('#clear-chat-history-btn');
                if (clearHistoryBtn) {
                    if (clearHistoryBtn.style.display === 'none') return; 
                    createInlineConfirmation(clearHistoryBtn, async () => {
                        const activeSession = state.sessions.find(s => s.id === state.activeSessionId);
                        if (activeSession) {
                            const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
                            await updateDoc(sessionRef, { messages: [], updatedAt: serverTimestamp() });
                        }
                    });
                    return;
                }

                const deleteMessageBtn = e.target.closest('.delete-message-btn');
                if (deleteMessageBtn) {
                    const messageIndex = parseInt(deleteMessageBtn.dataset.messageIndex, 10);
                    const activeSession = state.sessions.find(s => s.id === state.activeSessionId);
                    if (activeSession && !isNaN(messageIndex)) {
                        const onConfirm = async () => {
                            const newMessages = activeSession.messages.filter((_, index) => index !== messageIndex);
                            const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
                            await updateDoc(sessionRef, { messages: newMessages });
                        };
                        if (deleteMessageBtn.closest('.message-actions-dropdown')) {
                            requestConfirmationInMenu(deleteMessageBtn, onConfirm);
                        } else {
                            createInlineConfirmation(deleteMessageBtn, onConfirm);
                        }
                    }
                    return;
                }

                const speakBtn = e.target.closest('.speak-message-btn');
                if (speakBtn) {
                    handleSpeakButtonClick(e);
                    return;
                }
                
                const voiceOptionBtn = e.target.closest('.voice-option-btn');
                if (voiceOptionBtn) {
                    handleVoiceSelectionClick(e);
                    return;
                }
                    
                const handleRegeneration = (clickedBtn, messageIndex, sliceEnd) => {
                    if (state.loadingSessionId) return;
                    const activeSession = state.sessions.find(s => s.id === state.activeSessionId);
                    if (!activeSession || isNaN(messageIndex)) return;
                    requestConfirmationInMenu(clickedBtn, async () => {
                        const messagesForRegen = activeSession.messages.slice(0, sliceEnd);
                        const provider = state.providers.find(p => p.id === activeSession.providerId);
                        const selectedRole = state.roles.find(r => r.id === activeSession.roleId);
                        const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
                        await updateDoc(sessionRef, { messages: messagesForRegen, updatedAt: serverTimestamp() });
                        await generateAssistantResponse(state.activeSessionId, messagesForRegen, provider, selectedRole, activeSession.modelName);
                    });
                };
                
                const regenerateUserBtn = e.target.closest('.regenerate-user-message-btn');
                if (regenerateUserBtn) {
                    const messageIndex = parseInt(regenerateUserBtn.dataset.messageIndex, 10);
                    handleRegeneration(regenerateUserBtn, messageIndex, messageIndex + 1);
                    return;
                }
    
                const regenerateBtn = e.target.closest('.regenerate-message-btn');
                if (regenerateBtn) {
                    const messageIndex = parseInt(regenerateBtn.dataset.messageIndex, 10);
                    handleRegeneration(regenerateBtn, messageIndex, messageIndex);
                    return;
                }
        
                const editBtn = e.target.closest('.edit-message-btn');
                if (editBtn) {
                    if (state.loadingSessionId) return;
                    const messageContainer = editBtn.closest('.message-container');
                    const contentDiv = messageContainer.querySelector('.prose');
                    if (messageContainer.querySelector('.edit-form')) return; 
        
                    const messageIndex = parseInt(editBtn.dataset.messageIndex, 10);
                    const activeSession = state.sessions.find(s => s.id === state.activeSessionId);
                    const originalContent = activeSession.messages[messageIndex].content;
        
                    contentDiv.classList.add('hidden');
        
                    const editForm = document.createElement('div');
                    editForm.className = 'edit-form w-full mt-2';
                    editForm.innerHTML = `
                        <textarea class="w-full bg-input border border-border-color rounded-lg p-3 resize-none focus:outline-none focus:ring-2 focus:ring-accent" rows="3"></textarea>
                        <div class="flex justify-start items-center mt-2 space-x-2">
                             <button type="button" class="cancel-edit-btn px-4 py-2 rounded-md bg-bg-input hover:bg-gray-600 transition-colors">Отмена</button>
                             <button type="button" class="save-edit-btn px-4 py-2 rounded-md bg-accent hover:bg-accent-hover text-white transition-colors">Завершить</button>
                        </div>
                    `;
                    
                    contentDiv.after(editForm);
                    
                    const textarea = editForm.querySelector('textarea');
                    textarea.value = originalContent;
                    textarea.focus();
                    textarea.style.height = 'auto';
                    textarea.style.height = (textarea.scrollHeight) + 'px';
                    textarea.addEventListener('input', () => {
                       textarea.style.height = 'auto';
                       textarea.style.height = (textarea.scrollHeight) + 'px';
                    });
        
                    editForm.querySelector('.save-edit-btn').addEventListener('click', async () => {
                        const newContent = textarea.value.trim();
                        if (newContent) {
                            editForm.remove();
                            contentDiv.classList.remove('hidden');
                            
                            const messagesForSubmit = activeSession.messages.slice(0, messageIndex);
                            messagesForSubmit.push({ role: 'user', content: newContent });
                            
                            const provider = state.providers.find(p => p.id === activeSession.providerId);
                            const selectedRole = state.roles.find(r => r.id === activeSession.roleId);
    
                            const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
                            await updateDoc(sessionRef, { messages: messagesForSubmit, updatedAt: serverTimestamp() });
                            
                            await generateAssistantResponse(
                                state.activeSessionId,
                                messagesForSubmit,
                                provider,
                                selectedRole,
                                activeSession.modelName
                            );
                        }
                    });
        
                    editForm.querySelector('.cancel-edit-btn').addEventListener('click', () => {
                        editForm.remove();
                        contentDiv.classList.remove('hidden');
                    });
                }
                
                // --- Управление Провайдерами и Ролями из Настроек ---
                if (e.target.closest('#add-new-provider-btn')) handleAddProvider();
                if (e.target.closest('#add-new-role-btn')) handleAddRole();
                if (e.target.closest('#add-new-pipeline-btn')) handleAddPipeline();

                const deleteProviderBtn = e.target.closest('.delete-provider-btn');
                if (deleteProviderBtn) createInlineConfirmation(deleteProviderBtn, async () => await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/providers`, deleteProviderBtn.dataset.id)));
                
                const editProviderBtn = e.target.closest('.edit-provider-btn');
                if (editProviderBtn) handleOpenEditProviderModal(editProviderBtn.dataset.id);

                const deleteRoleBtn = e.target.closest('.delete-role-btn');
                if (deleteRoleBtn) createInlineConfirmation(deleteRoleBtn, async () => await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/roles`, deleteRoleBtn.dataset.id)));
                
                const editRoleBtn = e.target.closest('.edit-role-btn');
                if (editRoleBtn) handleOpenEditRoleModal(editRoleBtn.dataset.id);

                const deletePipelineBtn = e.target.closest('.delete-pipeline-btn');
                if (deletePipelineBtn) createInlineConfirmation(deletePipelineBtn, async () => await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/pipelines`, deletePipelineBtn.dataset.id)));
                
                const editPipelineBtn = e.target.closest('.edit-pipeline-btn');
                if (editPipelineBtn) handleOpenEditPipelineModal(editPipelineBtn.dataset.id);
            });

            // --- ЛОГИКА МОДАЛЬНОГО ОКНА РЕДАКТОРА ПАЙПЛАЙНОВ ---
            if (editPipelineModal) {
                // Обработчик кликов внутри модального окна (добавление/удаление шагов)
                editPipelineModal.addEventListener('click', (e) => {
                    const stepsContainer = document.getElementById('pipeline-steps-container');
                    if (!stepsContainer) return;
                    
                    const removeBtn = e.target.closest('.remove-pipeline-step-btn');
                    if (removeBtn) {
                        const stepElement = removeBtn.closest('.pipeline-step');
                        stepElement?.remove();
                        const remainingSteps = stepsContainer.querySelectorAll('.pipeline-step');
                        remainingSteps.forEach((step, index) => {
                            step.dataset.stepIndex = index;
                            step.querySelector('span.font-bold').textContent = `Шаг ${index + 1}`;
                        });
                        if(remainingSteps.length === 0) {
                             stepsContainer.innerHTML = '<p id="no-steps-message" class="text-center text-sm text-text-secondary py-4">В этом пайплайне пока нет шагов. Нажмите "Добавить шаг", чтобы начать.</p>';
                        }
                        return;
                    }

                    const addBtn = e.target.closest('#add-pipeline-step-btn');
                    if (addBtn) {
                        document.getElementById('no-steps-message')?.remove();
                        const newStepIndex = stepsContainer.querySelectorAll('.pipeline-step').length;
                        const newStepData = { providerId: '', modelName: '', roleContent: '' };
                        const stepHTML = renderPipelineStep(newStepData, newStepIndex);
                        stepsContainer.insertAdjacentHTML('beforeend', stepHTML);
                        lucide.createIcons();
                        return;
                    }
                });

                // Обработчик изменения провайдера для динамической смены моделей
                editPipelineModal.addEventListener('change', (e) => {
                    const providerSelect = e.target;
                    if (providerSelect.matches('.step-provider-select')) {
                        const stepElement = providerSelect.closest('.pipeline-step');
                        const modelSelect = stepElement.querySelector('.step-model-select');
                        const selectedProviderId = providerSelect.value;
                        const provider = state.providers.find(p => p.id === selectedProviderId);
                        if (provider && provider.models && provider.models.length > 0) {
                            modelSelect.innerHTML = provider.models.map(m => `<option value="${m}">${m}</option>`).join('');
                            modelSelect.disabled = false;
                        } else {
                            modelSelect.innerHTML = '<option value="" disabled selected>Нет доступных моделей</option>';
                            modelSelect.disabled = true;
                        }
                    }
                });
                
                // Обработчик кнопки "Отмена" в модальном окне
                editPipelineCancelBtn.addEventListener('click', () => {
                    editPipelineModal.classList.add('hidden');
                });

                // ОБРАБОТЧИК СОХРАНЕНИЯ ПАЙПЛАЙНА
                editPipelineForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const pipelineId = document.getElementById('edit-pipeline-id').value;
                    if (!pipelineId) return showModalAlert("Ошибка: ID пайплайна не найден.");

                    const newName = document.getElementById('edit-pipeline-name').value;
                    const steps = [];
                    const stepElements = document.querySelectorAll('.pipeline-step');

                    for (const stepEl of stepElements) {
                        const providerId = stepEl.querySelector('.step-provider-select').value;
                        const modelName = stepEl.querySelector('.step-model-select').value;
                        const roleContent = stepEl.querySelector('.step-role-content').value;
                        if (providerId && modelName) {
                            steps.push({ providerId, modelName, roleContent });
                        } else {
                            return showModalAlert(`Заполните провайдера и модель для шага ${steps.length + 1}.`);
                        }
                    }

                    const updatedData = { name: newName, steps: steps };
                    const pipelineRef = doc(db, `artifacts/${appId}/users/${userId}/pipelines`, pipelineId);
                    await updateDoc(pipelineRef, updatedData);
                    editPipelineModal.classList.add('hidden');
                });
            }
            
            // --- ОСТАЛЬНЫЕ ОБРАБОТЧИКИ (МОДАЛЬНЫЕ ОКНА, АУТЕНТИФИКАЦИЯ) ---
            confirmModalYesBtn.addEventListener('click', () => { if (confirmModalCallback) confirmModalCallback(); hideConfirmModal(); });
            confirmModalNoBtn.addEventListener('click', () => { if(confirmModalNoBtn.textContent === 'OK' && confirmModalCallback) confirmModalCallback(); hideConfirmModal(); });

            const fullscreenModal = document.getElementById('fullscreen-modal');
            fullscreenModal?.addEventListener('click', (e) => e.target === fullscreenModal && hideFullscreenMessage());
            document.getElementById('fullscreen-modal-close')?.addEventListener('click', hideFullscreenMessage);
            
            editProviderForm?.addEventListener('submit', handleEditProviderSubmit);
            editProviderCancelBtn?.addEventListener('click', () => editProviderModal.classList.add('hidden'));
        
            editRoleForm?.addEventListener('submit', handleEditRoleSubmit);
            editRoleCancelBtn?.addEventListener('click', () => editRoleModal.classList.add('hidden'));
        
            document.getElementById('google-signin-btn')?.addEventListener('click', async () => { try { await signInWithPopup(auth, new GoogleAuthProvider()); } catch (error) { console.error("Google sign-in error", error); showModalAlert("Не удалось войти через Google. Ошибка: " + error.message); }});
            document.getElementById('sign-out-btn')?.addEventListener('click', async (e) => { e.preventDefault(); try { await signOut(auth); } catch (error) { console.error("Sign-out error", error); }});
        }

        function renderPipelineStep(step, index) {
            // Генерируем опции для выбора провайдера
            const providerOptions = state.providers.map(p => `<option value="${p.id}" ${p.id === step.providerId ? 'selected' : ''}>${p.name}</option>`).join('');

            // Генерируем опции для выбора модели на основе выбранного провайдера
            let modelOptions = '<option value="" disabled>Сначала выберите провайдера</option>';
            const selectedProvider = state.providers.find(p => p.id === step.providerId);
            if (selectedProvider && selectedProvider.models) {
                modelOptions = selectedProvider.models.map(m => `<option value="${m}" ${m === step.modelName ? 'selected' : ''}>${m}</option>`).join('');
            }

            // HTML-структура для одного шага
            const stepHTML = `
                <div class="pipeline-step bg-bg-main p-3 rounded-lg border border-border-color" data-step-index="${index}">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-bold text-text-secondary">Шаг ${index + 1}</span>
                        <button type="button" class="remove-pipeline-step-btn p-1.5 text-text-secondary hover:text-red-400 transition-colors" title="Удалить шаг">
                            <i data-lucide="x" class="w-5 h-5"></i>
                        </button>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                        <div>
                            <label class="text-xs text-text-secondary block mb-1">Провайдер</label>
                            <select class="step-provider-select w-full bg-input border border-border-color rounded p-2 text-sm focus:outline-none focus:ring-2 focus:ring-accent">
                                <option value="" disabled ${!step.providerId ? 'selected' : ''}>-- Выберите --</option>
                                ${providerOptions}
                            </select>
                        </div>
                        <div>
                            <label class="text-xs text-text-secondary block mb-1">Модель</label>
                            <select class="step-model-select w-full bg-input border border-border-color rounded p-2 text-sm focus:outline-none focus:ring-2 focus:ring-accent" ${!selectedProvider ? 'disabled' : ''}>
                                ${modelOptions}
                            </select>
                        </div>
                    </div>
                    <div class="mt-3">
                        <label class="text-xs text-text-secondary block mb-1">Роль на этом шаге (Системный промпт)</label>
                        <textarea class="step-role-content w-full bg-input p-2 rounded border border-border-color focus:outline-none focus:ring-2 focus:ring-accent" rows="3" placeholder="Например: Ты — опытный копирайтер, который пишет краткие и броские заголовки.">${step.roleContent || ''}</textarea>
                    </div>
                </div>
            `;
            return stepHTML;
        }

        function handleOpenEditPipelineModal(pipelineId) {
            const pipelineToEdit = state.pipelines.find(p => p.id === pipelineId);
            if (!pipelineToEdit) {
                console.error("Пайплайн для редактирования не найден:", pipelineId);
                return;
            }

            // Заполняем простые поля
            document.getElementById('edit-pipeline-id').value = pipelineToEdit.id;
            document.getElementById('edit-pipeline-name').value = pipelineToEdit.name;

            // Находим контейнер для шагов
            const stepsContainer = document.getElementById('pipeline-steps-container');
            stepsContainer.innerHTML = ''; // Очищаем от предыдущих шагов

            // Отрисовываем каждый шаг пайплайна
            if (pipelineToEdit.steps && pipelineToEdit.steps.length > 0) {
                pipelineToEdit.steps.forEach((step, index) => {
                    const stepHTML = renderPipelineStep(step, index);
                    stepsContainer.insertAdjacentHTML('beforeend', stepHTML);
                });
            } else {
                // Если шагов нет, показываем сообщение
                stepsContainer.innerHTML = '<p id="no-steps-message" class="text-center text-sm text-text-secondary py-4">В этом пайплайне пока нет шагов. Нажмите "Добавить шаг", чтобы начать.</p>';
            }

            // Показываем иконки
            lucide.createIcons();

            // Открываем модальное окно
            editPipelineModal.classList.remove('hidden');
        }
        
        function attachFirestoreListeners() {
            unsubscribeSessions(); unsubscribeProviders(); unsubscribeRoles(); unsubscribePipelines(); // Добавили unsubscribePipelines
            if (!userId) return;
        
            // --- НОВЫЙ СЛУШАТЕЛЬ ДЛЯ ПАЙПЛАЙНОВ ---
            const pipelinesCol = collection(db, `artifacts/${appId}/users/${userId}/pipelines`);
            unsubscribePipelines = onSnapshot(pipelinesCol, (snapshot) => {
                state.pipelines = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))
                    .sort((a,b) => (b.createdAt?.toMillis() || 0) - (a.createdAt?.toMillis() || 0));
                
                if (state.activeTab === 'settings' && !state.isLoading) {
                    render();
                }
            }, error => console.error("Pipeline listener error: ", error));


            // --- СУЩЕСТВУЮЩИЕ СЛУШАТЕЛИ (без изменений) ---
            const sessionsCol = collection(db, `artifacts/${appId}/users/${userId}/sessions`);
            unsubscribeSessions = onSnapshot(sessionsCol, (snapshot) => {
                state.sessions = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))
                    .sort((a,b) => (b.updatedAt?.toMillis() || 0) - (a.updatedAt?.toMillis() || 0));
        
                const activeSessionExists = state.sessions.some(s => s.id === state.activeSessionId);
                if (!activeSessionExists) {
                    state.activeSessionId = null;
                }
                if (!state.isLoading) {
                    render();
                }
            }, error => console.error("Session listener error: ", error));
        
            const providersCol = collection(db, `artifacts/${appId}/users/${userId}/providers`);
            unsubscribeProviders = onSnapshot(providersCol, (snapshot) => {
                state.providers = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                if ((state.activeTab === 'settings' || state.activeTab === 'chat') && !state.isLoading) {
                    render();
                }
            }, error => console.error("Providers listener error: ", error));
        
            const rolesCol = collection(db, `artifacts/${appId}/users/${userId}/roles`);
            unsubscribeRoles = onSnapshot(rolesCol, (snapshot) => {
                state.roles = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })).sort((a, b) => (a.createdAt?.toMillis() || 0) - (b.createdAt?.toMillis() || 0));
                if ((state.activeTab === 'settings' || state.activeTab === 'chat') && !state.isLoading) {
                    render();
                }
            }, error => console.error("Roles listener error: ", error));
        }
    
        function resetState() {
            unsubscribeSessions(); unsubscribeProviders(); unsubscribeRoles();

            userId = null;
            state = { activeTab: 'chat', activeSessionId: null, sessions: [], providers: [], roles: [], isLoading: false, isAuthReady: false, isSidebarCollapsed: false };
            sidebar.classList.remove('collapsed', 'open');
            sidebarList.innerHTML = '<div class="p-4 text-center text-gray-500">Пожалуйста, войдите, чтобы начать работу.</div>';
            mainContent.innerHTML = getEmptyStateHTML('chat');
        }

        async function handleAddPipeline() {
            if (state.isLoading) return;
            state.isLoading = true;
            try {
                // Создаем базовую структуру для нового пайплайна
                const newPipelineData = {
                    name: 'Новый пайплайн',
                    steps: [], // Начинаем с пустого массива шагов
                    createdAt: serverTimestamp()
                };
                
                // Добавляем документ в коллекцию 'pipelines'
                const docRef = await addDoc(collection(db, `artifacts/${appId}/users/${userId}/pipelines`), newPipelineData);
                
                // Сразу же открываем модальное окно для редактирования созданного пайплайна
                handleOpenEditPipelineModal(docRef.id);

            } catch (error) {
                console.error("Ошибка при добавлении пайплайна: ", error);
                showModalAlert("Не удалось создать пайплайн.");
            } finally {
                state.isLoading = false;
            }
        }
        
       async function init() {
            const pipelineModalHTML = `
                <div id="edit-pipeline-modal" class="modal-overlay hidden">
                    <div class="modal-content !max-w-3xl">
                        <h3 class="text-xl font-semibold mb-4 flex-shrink-0">Редактировать пайплайн</h3>
                        <form id="edit-pipeline-form" class="flex flex-col flex-grow min-h-0">
                            <!-- Блок с названием (не скроллится) -->
                             <input type="hidden" id="edit-pipeline-id">
                            <div class="flex-shrink-0">
                                <label for="edit-pipeline-name" class="text-sm text-text-secondary block mb-1">Название пайплайна</label>
                                <input type="text" id="edit-pipeline-name" class="w-full bg-input p-2 rounded border border-border-color focus:outline-none focus:ring-2 focus:ring-accent" required>
                            </div>
        
                            <!-- Основная часть с прокруткой -->
                            <div class="flex-grow overflow-y-auto my-4 pr-3 -mr-4 border-t border-b border-border-color py-4">
                                <h4 class="text-lg font-semibold">Шаги выполнения</h4>
                                <div id="pipeline-steps-container" class="space-y-4 mt-3">
                                    <!-- Шаги пайплайна будут динамически добавляться сюда -->
                                </div>
                                <div class="pt-4">
                                    <button type="button" id="add-pipeline-step-btn" class="w-full flex items-center justify-center p-2 rounded-md border-2 border-dashed border-border-color hover:bg-bg-element transition-colors text-text-secondary">
                                        <i data-lucide="plus" class="w-5 h-5 mr-2"></i>Добавить шаг
                                    </button>
                                </div>
                            </div>
        
                            <!-- Кнопки внизу (не скроллятся) -->
                            <div class="flex justify-end space-x-3 mt-auto flex-shrink-0">
                                <button type="button" id="edit-pipeline-cancel-btn" class="px-4 py-2 rounded-md bg-bg-input hover:bg-gray-600 transition-colors">Отмена</button>
                                <button type="submit" class="px-4 py-2 rounded-md bg-accent hover:bg-accent-hover text-white transition-colors">Сохранить</button>
                            </div>
                        </form>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', pipelineModalHTML);
            
            editPipelineModal = document.getElementById('edit-pipeline-modal');
            editPipelineForm = document.getElementById('edit-pipeline-form');
            editPipelineCancelBtn = document.getElementById('edit-pipeline-cancel-btn');

            loadUserPreferences();
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                if ('speechSynthesis' in window) {
                    synth.getVoices(); 
                    synth.onvoiceschanged = loadAndSortVoices;
                } else {
                    console.warn("Web Speech API (Text-to-Speech) не поддерживается в этом браузере.");
                }
                
                // НОВЫЙ КОД: Получаем ссылки на элементы нового модального окна
                const authPromptModal = document.getElementById('auth-prompt-modal');
                const googleSignInBtnInModal = document.getElementById('google-signin-btn-modal');

                onAuthStateChanged(auth, (user) => {
                    const googleBtn = document.getElementById('google-signin-btn');
                    const userProfile = document.getElementById('user-profile');
                    const authSection = document.getElementById('auth-section');
                    authSection.classList.remove('hidden');
    
                    if (user) {
                        userId = user.uid;
                        googleBtn.classList.add('hidden');
                        userProfile.classList.remove('hidden');
                        document.getElementById('user-name').textContent = user.displayName || 'Анонимный пользователь';
                        document.getElementById('user-avatar').src = user.photoURL || `https://ui-avatars.com/api/?name=${user.displayName || 'A'}&background=random`;
                        
                        // НОВЫЙ КОД: Скрываем модальное окно, если пользователь вошел в систему
                        if (authPromptModal) authPromptModal.classList.add('hidden');

                        state.isAuthReady = true;
                        attachFirestoreListeners();
                    } else {
                        resetState();
                        googleBtn.classList.remove('hidden');
                        userProfile.classList.add('hidden');
                        
                        // НОВЫЙ КОД: Показываем модальное окно, если пользователь не авторизован
                        if (authPromptModal) authPromptModal.classList.remove('hidden');

                        state.isAuthReady = false; 
                        render();
                    }
                    renderMainNav(); 
                    updateSidebarView();
                });

                // НОВЫЙ КОД: Добавляем обработчики для кнопок нового модального окна
                if (googleSignInBtnInModal) {
                    googleSignInBtnInModal.addEventListener('click', async () => {
                        try {
                            await signInWithPopup(auth, new GoogleAuthProvider());
                            // Модальное окно закроется автоматически, т.к. сработает onAuthStateChanged
                        } catch (error) {
                            console.error("Google sign-in error from modal", error);
                            // Можно показать кастомное сообщение об ошибке
                            if (authPromptModal) authPromptModal.classList.add('hidden');
                            showModalAlert("Не удалось войти через Google. Ошибка: " + error.message);
                        }
                    });
                }
                
                setupGlobalEventListeners();
    
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                mainContent.innerHTML = `<div class="p-4 text-red-400"><strong>Ошибка инициализации Firebase:</strong> ${error.message}.</div>`;
            }
        }
        
        init();
    </script>

</body>
</html>
