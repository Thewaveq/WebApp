<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Multi-Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        const firebaseConfig = {
            apiKey: "__NEXT_PUBLIC_FIREBASE_API_KEY__",
            authDomain: "__NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN__",
            projectId: "__NEXT_PUBLIC_FIREBASE_PROJECT_ID__",
            storageBucket: "__NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET__",
            messagingSenderId: "__NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID__",
            appId: "__NEXT_PUBLIC_FIREBASE_APP_ID__",
            measurementId: "__NEXT_PUBLIC_FIREBASE_MEASUREMENT_ID__"
        };
    </script>
    
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.8/dist/purify.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- Стили вынесены в отдельный файл -->
    <link rel="stylesheet" href="styles.css">

</head>
<body class="h-dvh w-full flex">

    <div id="sidebar-backdrop" class="fixed inset-0 bg-black/60 backdrop-blur-sm z-30 lg:hidden"></div>
    <aside id="sidebar" class="bg-bg-sidebar flex flex-col h-full border-r border-border-color">
        <div class="p-4 border-b border-border-color flex justify-between items-center">
            <h1 class="text-xl font-bold flex items-center"><i data-lucide="sparkles" class="w-6 h-6 mr-2 text-accent"></i>AI Multi-Tool V33.</h1>
        </div>
        <div class="p-2 flex-shrink-0">
            <button id="new-chat-btn" class="w-full flex items-center justify-center bg-accent hover:bg-accent-hover text-white font-bold py-2 px-4 rounded transition-colors">
                <i data-lucide="plus" class="w-5 h-5 mr-2"></i>Новый чат
            </button>
             <button id="new-note-btn" class="w-full flex items-center justify-center bg-accent hover:bg-accent-hover text-white font-bold py-2 px-4 rounded transition-colors hidden">
                <i data-lucide="plus" class="w-5 h-5 mr-2"></i>Новая папка заметок
            </button>
        </div>
        <nav id="sidebar-list" class="flex-grow overflow-y-auto p-2">
        </nav>
        <div id="auth-section" class="p-3 border-t border-border-color text-center hidden">
            <button id="google-signin-btn" class="w-full flex items-center justify-center bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded transition-colors text-sm">
                <svg class="w-4 h-4 mr-2" viewBox="0 0 48 48" fill="currentColor"><path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"></path><path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"></path><path fill="#FBBC05" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"></path><path fill="#34A853" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"></path><path fill="none" d="M0 0h48v48H0z"></path></svg>
                Войти через Google
            </button>
            <div id="user-profile" class="hidden flex items-center text-left">
                <img id="user-avatar" class="w-8 h-8 rounded-full mr-2 flex-shrink-0">
                <div class="text-xs overflow-hidden">
                    <p id="user-name" class="font-semibold text-text-primary truncate"></p>
                    <a href="#" id="sign-out-btn" class="text-red-400 hover:text-red-500">Выйти</a>
                </div>
            </div>
        </div>
    </aside>

    <main class="flex-grow flex flex-col h-full min-w-0">
        <nav class="flex-shrink-0 border-b border-border-color flex items-center px-2">
            <button id="sidebar-toggle-btn" class="p-3 -ml-2 hover:bg-bg-element transition-colors border-r border-border-color">
                <i id="sidebar-toggle-icon" data-lucide="panel-left-close" class="w-5 h-5"></i>
            </button>
            
            <!-- Кнопки слева -->
            <button data-tab="chat" title="Чат" class="main-nav-item p-3 rounded-md text-text-secondary hover:text-white hover:bg-bg-element transition-colors active ml-2">
                <i data-lucide="message-square" class="w-5 h-5"></i>
            </button>
            <button data-tab="notepad" title="Заметки-карточки" class="main-nav-item p-3 rounded-md text-text-secondary hover:text-white hover:bg-bg-element transition-colors">
                <i data-lucide="notebook" class="w-5 h-5"></i>
            </button>
        
            <!-- Кнопка справа с автоматическим отступом слева -->
            <button data-tab="settings" title="Настройки" class="main-nav-item p-3 rounded-md text-text-secondary hover:text-white hover:bg-bg-element transition-colors ml-auto">
                <i data-lucide="settings" class="w-5 h-5"></i>
            </button>
        </nav>
        <div id="main-content" class="flex-grow overflow-y-auto">
        </div>
    </main>
    
    <div id="confirm-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <p id="confirm-modal-text" class="text-text-primary mb-6 text-center">Вы уверены?</p>
            <div class="flex justify-center space-x-4">
                <button id="confirm-modal-no" class="px-6 py-2 rounded-md bg-bg-input hover:bg-gray-600 transition-colors">Нет</button>
                <button id="confirm-modal-yes" class="px-6 py-2 rounded-md bg-danger hover:bg-danger-hover text-white transition-colors">Да</button>
            </div>
        </div>
    </div>
    
    <div id="edit-provider-modal" class="modal-overlay hidden">
        <div class="modal-content !max-w-xl">
            <h3 class="text-xl font-semibold mb-4">Редактировать провайдера</h3>
            <form id="edit-provider-form" class="space-y-3">
                <input type="hidden" id="edit-provider-id">
                <div>
                    <label for="edit-provider-name" class="text-sm text-text-secondary block mb-1">Название</label>
                    <input type="text" id="edit-provider-name" class="w-full bg-input p-2 rounded border border-border-color focus:outline-none focus:ring-2 focus:ring-accent" required>
                </div>
                <div>
                    <label for="edit-provider-url" class="text-sm text-text-secondary block mb-1">Базовый URL</label>
                    <input type="text" id="edit-provider-url" class="w-full bg-input p-2 rounded border border-border-color focus:outline-none focus:ring-2 focus:ring-accent" required>
                </div>
                 <div>
                    <label for="edit-provider-path" class="text-sm text-text-secondary block mb-1">Путь запроса</label>
                    <input type="text" id="edit-provider-path" class="w-full bg-input p-2 rounded border border-border-color focus:outline-none focus:ring-2 focus:ring-accent" required>
                </div>
                <div>
                    <label for="edit-provider-keys" class="text-sm text-text-secondary block mb-1">API Ключи (каждый с новой строки)</label>
                    <textarea id="edit-provider-keys" class="w-full bg-input p-2 rounded border border-border-color focus:outline-none focus:ring-2 focus:ring-accent" rows="4" required></textarea>
                </div>
                <div>
                    <label for="edit-provider-models" class="text-sm text-text-secondary block mb-1">Модели (каждая с новой строки)</label>
                    <textarea id="edit-provider-models" class="w-full bg-input p-2 rounded border border-border-color focus:outline-none focus:ring-2 focus:ring-accent" rows="4" required></textarea>
                </div>
                <div class="flex justify-end space-x-3 pt-4">
                    <button type="button" id="edit-provider-cancel-btn" class="px-4 py-2 rounded-md bg-bg-input hover:bg-gray-600 transition-colors">Отмена</button>
                    <button type="submit" class="px-4 py-2 rounded-md bg-accent hover:bg-accent-hover text-white transition-colors">Сохранить</button>
                </div>
            </form>
        </div>
    </div>
    
    <div id="edit-role-modal" class="modal-overlay hidden">
        <div class="modal-content !max-w-xl">
            <h3 class="text-xl font-semibold mb-4">Редактировать роль</h3>
            <form id="edit-role-form" class="space-y-3">
                <input type="hidden" id="edit-role-id">
                <div>
                    <label for="edit-role-name" class="text-sm text-text-secondary block mb-1">Название роли</label>
                    <input type="text" id="edit-role-name" class="w-full bg-input p-2 rounded border border-border-color focus:outline-none focus:ring-2 focus:ring-accent" required>
                </div>
                <div>
                    <label for="edit-role-content" class="text-sm text-text-secondary block mb-1">Содержимое роли (Системный промпт)</label>
                    <textarea id="edit-role-content" class="w-full bg-input p-2 rounded border border-border-color focus:outline-none focus:ring-2 focus:ring-accent" rows="8" required></textarea>
                </div>
                <div class="flex justify-end space-x-3 pt-4">
                    <button type="button" id="edit-role-cancel-btn" class="px-4 py-2 rounded-md bg-bg-input hover:bg-gray-600 transition-colors">Отмена</button>
                    <button type="submit" class="px-4 py-2 rounded-md bg-accent hover:bg-accent-hover text-white transition-colors">Сохранить</button>
                </div>
            </form>
        </div>
    </div>
    <div id="in-app-notification" class="fixed top-5 left-1/2 -translate-x-1/2 z-50 w-full max-w-md cursor-pointer transition-all duration-300 ease-in-out transform -translate-y-[150%] opacity-0 hidden" >
        <div class="bg-bg-sidebar rounded-lg shadow-2xl border border-accent/50 p-4 mx-4 flex items-start space-x-3">
            <div class="flex-shrink-0 w-8 h-8 rounded-full bg-accent flex items-center justify-center mt-1">
                <i data-lucide="sparkles" class="w-5 h-5 text-white"></i>
            </div>
            <div class="flex-grow overflow-hidden">
                <h4 id="in-app-notification-title" class="font-bold text-text-primary text-md">Новый ответ!</h4>
                <p id="in-app-notification-body" class="text-sm text-text-secondary truncate">Получен новый ответ в чате.</p>
            </div>
            <button id="in-app-notification-close" class="flex-shrink-0 text-text-secondary hover:text-white p-1 -mr-2 -mt-2">
                <i data-lucide="x" class="w-4 h-4"></i>
            </button>
        </div>
    </div>
    <script type="module">
        // --- ИМПОРТЫ ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, collection, addDoc, setDoc, deleteDoc, updateDoc, serverTimestamp, deleteField, arrayUnion, arrayRemove } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    
        // --- ИНИЦИАЛИЗАЦИЯ FIREBASE ---
        const app = initializeApp(firebaseConfig);
        
        // --- ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    
        let db = getFirestore(app);
        let auth = getAuth(app);
        let userId;
        let unsubscribeSessions = () => {};
        let unsubscribeProviders = () => {};
        let unsubscribeRoles = () => {};
        let chatObserver = null;
        let generationAbortController = null;
        let notificationTimeout = null;
    
        let state = {
            activeTab: 'chat',
            activeSessionId: null,
            sessions: [],
            providers: [],
            roles: [],
            loadingSessionId: null,
            isAuthReady: false,
            isSidebarCollapsed: false,
            isChatWidthCompact: true,
            isNotepadWidthCompact: true,
            isSettingsPanelExpanded: false,
        };
        
        let confirmModalCallback = null;
        
        const sidebar = document.getElementById('sidebar');
        const sidebarList = document.getElementById('sidebar-list');
        const mainContent = document.getElementById('main-content');
        const mainNavItems = document.querySelectorAll('.main-nav-item');
        const newChatBtn = document.getElementById('new-chat-btn');
        const newNoteBtn = document.getElementById('new-note-btn');
        const confirmModal = document.getElementById('confirm-modal');
        const confirmModalText = document.getElementById('confirm-modal-text');
        const confirmModalYesBtn = document.getElementById('confirm-modal-yes');
        const confirmModalNoBtn = document.getElementById('confirm-modal-no');
        const sidebarBackdrop = document.getElementById('sidebar-backdrop');
        const editProviderModal = document.getElementById('edit-provider-modal');
        const editProviderForm = document.getElementById('edit-provider-form');
        const editProviderCancelBtn = document.getElementById('edit-provider-cancel-btn');
        const editRoleModal = document.getElementById('edit-role-modal');
        const editRoleForm = document.getElementById('edit-role-form');
        const editRoleCancelBtn = document.getElementById('edit-role-cancel-btn');

        // --- СОХРАНЕНИЕ СОСТОЯНИЯ ---
        function loadUserPreferences() {
            const savedCompactMode = localStorage.getItem('chatViewCompact');
            if (savedCompactMode !== null) {
                state.isChatWidthCompact = (savedCompactMode === 'true');
            }

            const savedNotepadCompactMode = localStorage.getItem('notepadViewCompact');
            if (savedNotepadCompactMode !== null) {
                state.isNotepadWidthCompact = (savedNotepadCompactMode === 'true');
            }
        }
    
        // --- ФУНКЦИИ РЕНДЕРИНГА ---
        function render() {
            if (!state.isAuthReady) return;
            renderSidebar();
            renderMainContent();
            renderMainNav();
        }
    
        function renderSidebar() {
            sidebarList.innerHTML = '';
            const filteredSessions = state.sessions.filter(s => s.type === state.activeTab);
            const isMobile = window.innerWidth < 1024;
        
            if (filteredSessions.length > 0) {
                filteredSessions.forEach(session => {
                    const item = document.createElement('div');
                    const isActive = session.id === state.activeSessionId;

                    item.className = `sidebar-item flex justify-between items-center p-2 my-1 rounded-md cursor-pointer transition-colors duration-200 ${isActive ? 'active' : ''}`;
                    
                    item.innerHTML = `
                        <span class="truncate pr-2">${session.title || 'Без названия'}</span>
                        <button class="delete-session-btn hidden text-text-secondary hover:text-red-400" data-id="${session.id}">
                            <i data-lucide="trash-2" class="w-4 h-4"></i>
                        </button>
                    `;
                    
                    const deleteBtn = item.querySelector('.delete-session-btn');

                    if (isMobile && isActive) {
                        deleteBtn.classList.remove('hidden');
                    }
                    
                    item.addEventListener('click', (e) => {
                        if (e.target.closest('.delete-session-btn')) return;
                        state.activeSessionId = session.id;
                        render(); 
                    });
                    
                    item.addEventListener('mouseenter', () => {
                        if (!isMobile) {
                            deleteBtn.classList.remove('hidden');
                        }
                    });
                    
                    item.addEventListener('mouseleave', () => {
                        if (!isMobile) {
                            deleteBtn.classList.add('hidden');
                        }
                    });
                    
                    sidebarList.appendChild(item);
                });
            } else if (state.activeTab === 'chat' || state.activeTab === 'notepad') {
                 const typeTextMap = {
                     chat: 'чатов',
                     notepad: 'папок с заметками'
                 };
                 sidebarList.innerHTML = `<div class="text-center text-sm text-gray-500 p-4">Нет ${typeTextMap[state.activeTab] || 'элементов'}.</div>`;
            } else {
                 sidebarList.innerHTML = ''; 
            }
            lucide.createIcons();
        }
    
        function renderMainContent() {
            if (chatObserver) {
                chatObserver.disconnect();
                chatObserver = null;
            }

            const activeSession = state.sessions.find(s => s.id === state.activeSessionId);
            
            // Определяем, нужно ли полностью перерисовывать контент.
            // Это нужно при смене вкладки (chat -> notepad) или при выборе другой сессии в сайдбаре.
            const needsFullRender = mainContent.dataset.activeTabType !== state.activeTab ||
                                  mainContent.dataset.activeSessionId !== (state.activeSessionId || '');

            // Если полная перерисовка не нужна и мы находимся во вкладке с активной сессией,
            // то мы не перерисовываем все, а только обновляем динамические части.
            if (!needsFullRender && activeSession) {
                 if (state.activeTab === 'chat') {
                    // Для чата обновляем только сообщения и индикатор загрузки
                    renderChatMessages(activeSession);
                    updateLoadingIndicator();
                 } else if (state.activeTab === 'notepad') {
                    // Для заметок обновляем только список карточек
                    renderNotepadCards(activeSession);
                 }
                 return; // Выходим, чтобы не выполнять лишний код полной перерисовки ниже
            }

            // --- ЕСЛИ ТРЕБУЕТСЯ ПОЛНАЯ ПЕРЕРИСОВКА ---
            mainContent.innerHTML = ''; // Очищаем полностью, только когда это необходимо
            mainContent.dataset.activeTabType = state.activeTab;
            mainContent.dataset.activeSessionId = state.activeSessionId || '';

            switch (state.activeTab) {
                case 'chat':
                    if (activeSession) {
                        const chatContainer = document.createElement('div');
                        chatContainer.id = 'chat-view-container';
                        chatContainer.className = 'flex flex-col h-full';
                        chatContainer.innerHTML = getChatViewHTML(activeSession);
                        mainContent.appendChild(chatContainer);

                        const provider = state.providers.find(p => p.id === activeSession.providerId);
                        let needsUpdate = false;
                        const updatePayload = {};

                        if (!provider && state.providers.length > 0) {
                            const firstProvider = state.providers[0];
                            const models = firstProvider.models || [];
                            updatePayload.providerId = firstProvider.id;
                            updatePayload.modelName = models.length > 0 ? models[0] : null;
                            needsUpdate = true;
                        } else if (provider && !activeSession.modelName) {
                            const models = provider.models || [];
                            if (models.length > 0) {
                                updatePayload.modelName = models[0];
                                needsUpdate = true;
                            }
                        }

                        if (needsUpdate) {
                            const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
                            updateDoc(sessionRef, updatePayload);
                        }

                        renderChatMessages(activeSession);
                        setupChatViewEventListeners();
                        updateLoadingIndicator();
                    } else {
                         mainContent.innerHTML = getEmptyStateHTML('chat');
                    }
                    break;
                case 'notepad':
                     if (activeSession) {
                        mainContent.innerHTML = getNotepadViewHTML(activeSession);
                        setupNotepadViewEventListeners();
                        // ВОЗВРАЩАЕМ ПРОКРУТКУ ВНИЗ ПРИ ПЕРВОЙ ЗАГРУЗКЕ
                        const scrollContainer = document.getElementById('notepad-scroll-container');
                        if(scrollContainer) {
                            // Прокручиваем в самый низ, чтобы видеть последние заметки и кнопку добавления
                            setTimeout(() => {
                               scrollContainer.scrollTop = scrollContainer.scrollHeight;
                            }, 0);
                        }
                    } else {
                        mainContent.innerHTML = getEmptyStateHTML('notepad');
                    }
                    break;
                case 'settings':
                    mainContent.innerHTML = getSettingsViewHTML();
                    renderProviders();
                    renderRoles();
                    setupSettingsViewEventListeners();
                    break;
            }
            lucide.createIcons();
        }
        
        function renderMainNav() {
            mainNavItems.forEach(item => {
                item.classList.toggle('active', item.dataset.tab === state.activeTab);
            });
            newChatBtn.classList.toggle('hidden', state.activeTab !== 'chat');
            newNoteBtn.classList.toggle('hidden', state.activeTab !== 'notepad');
        }

        function renderNotepadCards(session) {
            const cardsGrid = document.getElementById('note-cards-grid');
            if (!cardsGrid) return;
        

            function autoResizeTextarea(textarea) {
                if (!textarea) return;

                setTimeout(() => {
                    textarea.style.height = 'auto';
                    textarea.style.height = (textarea.scrollHeight) + 'px';
                }, 0);
            }
        
            const newCards = session.cards || [];
            const newCardIds = new Set(newCards.map(c => c.id));
            const addButton = document.getElementById('add-new-card-btn');
        

            const existingCardElements = cardsGrid.querySelectorAll('.note-card');
            existingCardElements.forEach(cardEl => {
                const cardId = cardEl.dataset.cardId;
                if (!newCardIds.has(cardId)) {
                    cardEl.remove();
                }
            });
        

            newCards.forEach((cardData, index) => {
                let cardEl = cardsGrid.querySelector(`.note-card[data-card-id="${cardData.id}"]`);
        
                if (cardEl) {

                    const titleInput = cardEl.querySelector('.note-card-title');
                    const contentTextarea = cardEl.querySelector('.note-card-content');
                    
                    if (document.activeElement !== titleInput && titleInput.value !== cardData.title) {
                        titleInput.value = cardData.title || '';
                    }
                    if (document.activeElement !== contentTextarea && contentTextarea.value !== cardData.content) {
                        contentTextarea.value = cardData.content || '';

                        autoResizeTextarea(contentTextarea);
                    }
                } else {

                    const newCardHTML = getCardHTML(cardData);
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = newCardHTML;
                    const newCardElement = tempDiv.firstElementChild;
                    
                    cardsGrid.insertBefore(newCardElement, addButton);
                    lucide.createIcons({ nodes: [newCardElement] });
                    
                    const newTextarea = newCardElement.querySelector('.note-card-content');
                    autoResizeTextarea(newTextarea);
                }
            });
        }
    
        // --- ШАБЛОНЫ HTML ---
        function getEmptyStateHTML(type) {
            const iconMap = {
                'chat': 'message-square',
                'notepad': 'notebook'
            };
            const textMap = {
                'chat': 'Выберите чат или создайте новый',
                'notepad': 'Выберите папку с заметками-карточками или создайте новую'
            };
            const icon = iconMap[type] || 'alert-circle';
            const text = textMap[type] || 'Выберите элемент';
            return `<div class="flex flex-col h-full items-center justify-center text-gray-500 text-center p-4"><i data-lucide="${icon}" class="w-16 h-16 mb-4"></i><h2 class="text-2xl">${text}</h2></div>`;
        }
        
        function getChatViewHTML(activeSession) { 
            const roleOptions = state.roles.map(r => `<option value="${r.id}" ${r.id === activeSession.roleId ? 'selected' : ''}>${r.name}</option>`).join('');
        
            const providerOptions = state.providers.map(p => `<option value="${p.id}" ${p.id === activeSession.providerId ? 'selected' : ''}>${p.name}</option>`).join('');
        
            let modelOptions = '<option disabled>Выберите провайдера</option>';
            const selectedProvider = state.providers.find(p => p.id === activeSession.providerId);
            
            if (selectedProvider) {
                const models = selectedProvider.models || [];
                if (models.length > 0) {
                   modelOptions = models.map(m => `<option value="${m}" ${m === activeSession.modelName ? 'selected' : ''}>${m}</option>`).join('');
                } else {
                   modelOptions = '<option disabled>Нет моделей</option>';
                }
            }
            
            const isExpanded = state.isSettingsPanelExpanded;
            const panelClasses = `collapsible-panel ${isExpanded ? 'expanded' : ''}`;
            const iconClasses = `w-5 h-5 transition-transform ${isExpanded ? 'expanded' : ''}`;
        
            return `<div class="flex flex-col h-full">
                <div class="flex-shrink-0 p-3 border-b border-border-color">
                    <div class="flex items-center justify-between gap-3">
                        <button id="chat-width-toggle" title="Переключить ширину чата" class="p-2 rounded-md bg-bg-element hover:bg-bg-input hidden lg:flex flex-shrink-0">
                            <i data-lucide="arrow-left-right" class="w-4 h-4"></i>
                        </button>
                        <input type="text" id="chat-title-input" class="bg-transparent text-lg font-semibold focus:outline-none focus:ring-1 focus:ring-accent rounded px-2 py-1 flex-grow min-w-0" value="${activeSession.title || ''}" placeholder="Название чата">
                        <button id="chat-settings-toggle" class="p-1 rounded-full hover:bg-bg-element transition-colors flex-shrink-0">
                            <i data-lucide="chevron-down" id="chat-settings-icon" class="${iconClasses}"></i>
                        </button>
                    </div>
                    <div id="chat-settings-collapsible" class="${panelClasses}">
                        <div>
                            <div class="flex flex-col sm:flex-row items-center gap-3 w-full pt-3 flex-wrap">
                                <select id="role-select" class="bg-input border border-border-color rounded-md px-3 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-accent w-full sm:w-auto">
                                <option value="">Без роли</option>
                                ${roleOptions}
                                </select>
                                <select id="provider-select" class="bg-input border border-border-color rounded-md px-3 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-accent w-full sm:w-auto flex-grow sm:flex-grow-0">
                                    ${providerOptions.length > 0 ? providerOptions : '<option disabled>Добавьте провайдера</option>'}
                                </select>
                                <select id="model-select" class="bg-input border border-border-color rounded-md px-3 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-accent w-full sm:w-auto flex-grow sm:flex-grow-0">
                                    ${modelOptions}
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="flex-grow relative min-h-0">
                    <div id="chat-messages" class="absolute inset-0 p-4 overflow-y-auto ${state.isChatWidthCompact ? 'chat-view-compact' : ''}"></div>
                    <form id="chat-form" class="absolute bottom-0 left-0 right-0 p-4">
                        <div class="relative w-full max-w-4xl mx-auto">
                            <textarea id="chat-input" class="w-full bg-input border border-border-color rounded-lg p-3 pr-12 resize-none focus:outline-none focus:ring-2 focus:ring-accent" placeholder="Введите ваше сообщение..." rows="1"></textarea>
                            <button type="submit" class="absolute right-3 bottom-3 p-2 rounded-full bg-accent hover:bg-accent-hover transition-colors disabled:bg-gray-500">
                                <i data-lucide="send" class="w-5 h-5 text-white"></i>
                            </button>
                        </div>
                    </form>
                </div>
            </div>`; 
        }

        function getNotepadViewHTML(activeSession) {
            const cards = activeSession.cards || [];
            const cardsHTML = cards.map(getCardHTML).join('');
        
            return `
                <div class="flex flex-col h-full">
                    <div class="flex-shrink-0 p-3 border-b border-border-color">
                        <div class="flex items-center justify-between gap-3">
                            <button id="notepad-width-toggle" title="Переключить ширину контента" class="p-2 rounded-md bg-bg-element hover:bg-bg-input hidden lg:flex flex-shrink-0">
                                <i data-lucide="arrow-left-right" class="w-4 h-4"></i>
                            </button>
                            <input type="text" id="note-title-input" class="bg-transparent text-lg font-semibold focus:outline-none focus:ring-1 focus:ring-accent rounded px-2 py-1 flex-grow min-w-0" value="${activeSession.title || ''}" placeholder="Название папки с заметками">
                        </div>
                    </div>
                    
                    <div id="notepad-scroll-container" class="flex-grow overflow-y-auto p-4 ${state.isNotepadWidthCompact ? 'notepad-view-compact' : ''}">
                        <div id="note-cards-grid" class="grid grid-cols-1 gap-4 items-start">
                            ${cardsHTML}
                            <button id="add-new-card-btn" class="add-card-placeholder flex items-center justify-center rounded-lg border-2 border-dashed border-border-color hover:bg-bg-element transition-colors text-text-secondary p-4 min-h-[120px]">
                                <i data-lucide="plus" class="w-10 h-10"></i>
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function getCardHTML(card) {
            const title = card.title ? card.title.replace(/"/g, '"') : '';
            const content = card.content || '';

            return `
                <div class="note-card bg-bg-sidebar rounded-lg border border-border-color p-3 flex flex-col gap-2 transition-shadow hover:shadow-lg hover:border-accent/50" data-card-id="${card.id}">
                    <div class="note-card-header flex items-center justify-between">
                        <input type="text" class="note-card-title bg-transparent font-bold w-full focus:outline-none" placeholder="Заголовок" value="${title}">
                        <button class="note-card-delete-btn flex-shrink-0 text-text-secondary hover:text-red-400 ml-2" title="Удалить карточку">
                            <i data-lucide="x" class="w-4 h-4"></i>
                        </button>
                    </div>
                    <textarea class="note-card-content bg-transparent w-full resize-none focus:outline-none overflow-hidden text-sm" placeholder="Содержимое карточки...">${content}</textarea>
                </div>
            `;
        }
        
        function createMessageElement(msg, index) {
            const isUser = msg.role === 'user';
            
            const messageWrapper = document.createElement('div');

            messageWrapper.dataset.content = msg.content; 
            
            const baseClasses = 'message-container group relative flex flex-col mb-6 p-4 rounded-xl';
            const roleSpecificClasses = isUser ? 'user-message-bg items-end' : 'assistant-message-bg items-start';
            messageWrapper.className = `${baseClasses} ${roleSpecificClasses}`;
            
            const headerDiv = document.createElement('div');
            headerDiv.className = `flex items-center space-x-3`;

            const iconDiv = document.createElement('div');
            iconDiv.className = `w-7 h-7 rounded-full flex-shrink-0 flex items-center justify-center overflow-hidden`;

            if (isUser) {
                const user = auth.currentUser;

                const userNameSpan = document.createElement('span');
                userNameSpan.className = 'text-sm text-text-secondary'; 
                userNameSpan.textContent = user?.displayName || 'Вы';
                headerDiv.appendChild(userNameSpan);

                const avatarSrc = user?.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(user?.displayName || 'U')}&background=4285F4&color=fff`;
                iconDiv.innerHTML = `<img src="${avatarSrc}" alt="Аватар пользователя" class="w-full h-full object-cover">`;
                headerDiv.appendChild(iconDiv);
                
            } else {
                iconDiv.classList.add('bg-accent');
                iconDiv.innerHTML = `<i data-lucide="sparkles" class="w-4 h-4 text-white"></i>`;
                headerDiv.appendChild(iconDiv);
                
                if (msg.modelName) {
                    const modelNameSpan = document.createElement('span');
                    modelNameSpan.className = 'text-sm text-text-secondary';
                    modelNameSpan.textContent = msg.modelName;
                    headerDiv.appendChild(modelNameSpan);
                }
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'flex-grow prose max-w-none mt-2 w-full'; 
            
            let processedContent = (msg.content || '').replace(
                /<think>([\s\S]*?)<\/think>/g,
                `<details><summary>Показать ход мыслей</summary><div>$1</div></details>`
            );
            
            const rawHtml = marked.parse(processedContent, { breaks: true, gfm: true });
            contentDiv.innerHTML = DOMPurify.sanitize(rawHtml, { ADD_TAGS: ['details', 'summary'] });

            const actionsContainer = document.createElement('div');
            actionsContainer.className = 'absolute bottom-1 right-2 flex items-center space-x-1 bg-bg-element p-1 rounded-md opacity-0 group-hover:opacity-100 transition-opacity z-10';

            if (isUser) {
                const regenerateUserBtn = document.createElement('button');
                regenerateUserBtn.className = 'regenerate-user-message-btn p-1 text-text-secondary hover:text-accent transition-colors';
                regenerateUserBtn.title = 'Перегенерировать ответ на это сообщение';
                regenerateUserBtn.dataset.messageIndex = index;
                regenerateUserBtn.innerHTML = `<i data-lucide="refresh-cw" class="w-4 h-4"></i>`;
                actionsContainer.appendChild(regenerateUserBtn);

                const editButton = document.createElement('button');
                editButton.className = 'edit-message-btn p-1 text-text-secondary hover:text-accent transition-colors';
                editButton.title = 'Редактировать и отправить заново';
                editButton.dataset.messageIndex = index;
                editButton.innerHTML = `<i data-lucide="pencil" class="w-4 h-4"></i>`;
                actionsContainer.appendChild(editButton);
            } else {
                const regenerateButton = document.createElement('button');
                regenerateButton.className = 'regenerate-message-btn p-1 text-text-secondary hover:text-accent transition-colors';
                regenerateButton.title = 'Перегенерировать ответ';
                regenerateButton.dataset.messageIndex = index;
                regenerateButton.innerHTML = `<i data-lucide="refresh-cw" class="w-4 h-4"></i>`;
                actionsContainer.appendChild(regenerateButton);
            }

            const copyButton = document.createElement('button');
            copyButton.className = 'p-1 text-text-secondary hover:text-accent transition-colors';
            copyButton.title = 'Копировать текст';
            copyButton.innerHTML = `<i data-lucide="clipboard" class="w-4 h-4"></i>`;
            copyButton.addEventListener('click', () => {
                navigator.clipboard.writeText(msg.content).then(() => {
                    copyButton.innerHTML = `<i data-lucide="check" class="w-4 h-4 text-green-400"></i>`;
                    lucide.createIcons({ nodes: [copyButton] });
                    setTimeout(() => {
                        copyButton.innerHTML = `<i data-lucide="clipboard" class="w-4 h-4"></i>`;
                        lucide.createIcons({ nodes: [copyButton] });
                    }, 2000);
                }).catch(err => {
                    console.error('Не удалось скопировать текст:', err);
                });
            });
            actionsContainer.appendChild(copyButton);

            const deleteButton = document.createElement('button');
            deleteButton.className = `delete-message-btn p-1 text-text-secondary hover:text-red-400 transition-colors`;
            deleteButton.title = 'Удалить сообщение';
            deleteButton.dataset.messageIndex = index;
            deleteButton.innerHTML = `<i data-lucide="trash-2" class="w-4 h-4"></i>`;
            actionsContainer.appendChild(deleteButton);
            
            messageWrapper.appendChild(headerDiv);
            messageWrapper.appendChild(contentDiv);
            messageWrapper.appendChild(actionsContainer);

            messageWrapper.querySelectorAll('pre code').forEach((block) => {
                const preElement = block.parentElement;
                if (preElement.querySelector('.copy-code-btn')) return;
                
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-code-btn';
                copyBtn.innerHTML = '<i data-lucide="copy" class="w-4 h-4"></i>';
                copyBtn.addEventListener('click', () => {
                    navigator.clipboard.writeText(block.innerText);
                    copyBtn.innerHTML = '<i data-lucide="check" class="w-4 h-4 text-green-400"></i>';
                    setTimeout(() => {
                        copyBtn.innerHTML = '<i data-lucide="copy" class="w-4 h-4"></i>';
                        lucide.createIcons();
                    }, 2000);
                    lucide.createIcons();
                });
                preElement.appendChild(copyBtn);
                hljs.highlightElement(block);
            });

            lucide.createIcons({
                attrs: {
                    'stroke-width': 1.5
                },
                nodes: [messageWrapper]
            });

            return messageWrapper;
        }
        
        function renderChatMessages(session) {
            const messagesContainer = document.getElementById('chat-messages');
            if (!messagesContainer) return;

            // 1. Запоминаем, был ли пользователь в самом низу чата ДО изменений
            const isScrolledToBottom = messagesContainer.scrollHeight - messagesContainer.clientHeight <= messagesContainer.scrollTop + 5;

            const newMessages = session.messages || [];
            const existingMessageElements = messagesContainer.querySelectorAll('.message-container');

            // 2. "Умная" сверка и обновление DOM без полной перерисовки
            // Проходим по новому списку сообщений
            newMessages.forEach((msg, index) => {
                const existingEl = existingMessageElements[index];

                if (existingEl) {
                    // Если DOM-элемент для этого индекса уже есть, проверяем, не изменился ли он
                    const oldContent = existingEl.dataset.content;
                    if (oldContent !== msg.content) {
                        // Содержимое изменилось (редактирование/регенерация). Заменяем только этот элемент.
                        const newElement = createMessageElement(msg, index);
                        newElement.dataset.content = msg.content; // Сохраняем новое содержимое для будущих проверок
                        existingEl.replaceWith(newElement);
                    }
                } else {
                    // Если DOM-элемента для этого индекса нет, значит это новое сообщение. Добавляем его.
                    const newElement = createMessageElement(msg, index);
                    newElement.dataset.content = msg.content; // Сохраняем содержимое для будущих проверок
                    messagesContainer.appendChild(newElement);
                }
            });

            // Удаляем лишние DOM-элементы, если новый список сообщений стал короче
            if (existingMessageElements.length > newMessages.length) {
                for (let i = newMessages.length; i < existingMessageElements.length; i++) {
                    existingMessageElements[i].remove();
                }
            }
            
            // 3. Восстанавливаем прокрутку, если это было необходимо
            if (isScrolledToBottom) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }
        
        function renderRoles() {
            const list = document.getElementById('roles-list');
            if (!list) return;
            if (state.roles.length === 0) {
                list.innerHTML = `<p class="text-text-secondary md:col-span-2 xl:col-span-3 text-center py-10">Нет добавленных ролей. Нажмите "Добавить роль", чтобы создать новую.</p>`;
                return;
            }
            list.innerHTML = state.roles.map(r => `
                <div class="bg-bg-sidebar rounded-lg border border-border-color p-4 flex flex-col justify-between h-full transition-shadow hover:shadow-lg hover:border-accent/50">
                    <div>
                        <div class="flex justify-between items-start mb-2">
                            <h3 class="font-bold text-lg pr-2">${r.name}</h3>
                            <div class="flex items-center space-x-1 flex-shrink-0">
                                <button class="edit-role-btn p-1.5 text-text-secondary hover:text-accent transition-colors" data-id="${r.id}"><i data-lucide="edit" class="w-4 h-4"></i></button>
                                <button class="delete-role-btn p-1.5 text-text-secondary hover:text-red-400 transition-colors" data-id="${r.id}"><i data-lucide="trash-2" class="w-4 h-4"></i></button>
                            </div>
                        </div>
                        <p class="text-sm text-text-secondary bg-bg-input p-3 rounded-md line-clamp-3">${r.content}</p>
                    </div>
                </div>
            `).join('');
            lucide.createIcons();
        }
        
        function getSettingsViewHTML() {
            return `<div class="p-4 sm:p-6 space-y-4">
                <!-- Аккордеон для Провайдеров -->
                <details class="bg-bg-sidebar rounded-lg border border-border-color transition-shadow hover:shadow-lg">
                    <summary class="p-4 cursor-pointer font-bold text-xl flex justify-between items-center hover:bg-bg-element rounded-t-lg">
                        <span class="flex items-center"><i data-lucide="server" class="w-6 h-6 mr-3 text-accent"></i>Провайдеры API</span>
                        <i data-lucide="chevron-down" class="w-5 h-5 transition-transform details-arrow"></i>
                    </summary>
                    <div class="p-4 border-t border-border-color">
                        <div class="flex justify-end mb-6">
                            <button id="add-new-provider-btn" class="flex items-center px-4 py-2 bg-accent hover:bg-accent-hover rounded-md transition-colors flex-shrink-0">
                                <i data-lucide="plus" class="w-5 h-5 mr-2"></i>
                                Добавить провайдера
                            </button>
                        </div>
                        <div id="providers-list" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
                        </div>
                    </div>
                </details>
        
                <!-- Аккордеон для Ролей -->
                <details class="bg-bg-sidebar rounded-lg border border-border-color transition-shadow hover:shadow-lg">
                    <summary class="p-4 cursor-pointer font-bold text-xl flex justify-between items-center hover:bg-bg-element rounded-t-lg">
                        <span class="flex items-center"><i data-lucide="user-cog" class="w-6 h-6 mr-3 text-accent"></i>Управление ролями</span>
                        <i data-lucide="chevron-down" class="w-5 h-5 transition-transform details-arrow"></i>
                    </summary>
                    <div class="p-4 border-t border-border-color">
                        <div class="flex justify-end mb-6">
                            <button id="add-new-role-btn" class="flex items-center px-4 py-2 bg-accent hover:bg-accent-hover rounded-md transition-colors flex-shrink-0">
                                <i data-lucide="plus" class="w-5 h-5 mr-2"></i>
                                Добавить роль
                            </button>
                        </div>
                        <div id="roles-list" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4">
                        </div>
                    </div>
                </details>
            </div>`;
        }
    
        function renderProviders() { 
            const list = document.getElementById('providers-list'); 
            if (!list) return; 
            if (state.providers.length === 0) { 
                list.innerHTML = `<p class="text-text-secondary md:col-span-2 xl:col-span-3 text-center py-10">Нет добавленных провайдеров. Нажмите "Добавить провайдера", чтобы создать нового.</p>`; 
                return; 
            } 
            list.innerHTML = state.providers.map(p => {
                const keyCount = (p.apiKeys && p.apiKeys.length) > 0 ? p.apiKeys.length : 0;
                const models = p.models || (p.model ? [p.model] : []);
                const modelCount = models.length;

                return `
                <div class="bg-bg-sidebar rounded-lg border border-border-color p-4 flex flex-col justify-between h-full transition-shadow hover:shadow-lg hover:border-accent/50">
                    <div>
                        <div class="flex justify-between items-start mb-3">
                             <h3 class="font-bold text-lg pr-2">${p.name}</h3>
                             <div class="flex items-center space-x-1 flex-shrink-0">
                                <button class="edit-provider-btn p-1.5 text-text-secondary hover:text-accent transition-colors" data-id="${p.id}"><i data-lucide="edit" class="w-4 h-4"></i></button>
                                <button class="delete-provider-btn p-1.5 text-text-secondary hover:text-red-400 transition-colors" data-id="${p.id}"><i data-lucide="trash-2" class="w-4 h-4"></i></button>
                            </div>
                        </div>
                        <div class="space-y-2 text-sm">
                            <div class="flex items-center text-text-secondary"><i data-lucide="cpu" class="w-4 h-4 mr-2 flex-shrink-0"></i><span class="font-semibold text-text-primary mr-2">Моделей:</span> ${modelCount}</div>
                            <div class="flex items-center text-text-secondary"><i data-lucide="key-round" class="w-4 h-4 mr-2 flex-shrink-0"></i><span class="font-semibold text-text-primary mr-2">Ключей:</span> ${keyCount}</div>
                            <div class="flex items-start text-text-secondary"><i data-lucide="globe" class="w-4 h-4 mr-2 mt-0.5 flex-shrink-0"></i><span class="font-semibold text-text-primary mr-2">URL:</span> <span class="break-all">${p.baseUrl}${p.path}</span></div>
                        </div>
                    </div>
                </div>
                `
            }).join(''); 
            lucide.createIcons(); 
        }
        
        function setupChatViewEventListeners() {
            const form = document.getElementById('chat-form');
            const input = document.getElementById('chat-input');
            const titleInput = document.getElementById('chat-title-input');
            const providerSelect = document.getElementById('provider-select');
            const modelSelect = document.getElementById('model-select');
            const roleSelect = document.getElementById('role-select');
            const messagesContainer = document.getElementById('chat-messages');
            const chatViewContainer = document.getElementById('chat-view-container');

            const settingsToggle = document.getElementById('chat-settings-toggle');
            const settingsPanel = document.getElementById('chat-settings-collapsible');
            const settingsIcon = document.getElementById('chat-settings-icon');
            const widthToggleBtn = document.getElementById('chat-width-toggle');

            if (widthToggleBtn) {
                const isExpanded = !state.isChatWidthCompact;
                widthToggleBtn.classList.toggle('active', isExpanded);
                widthToggleBtn.title = isExpanded ? "Вернуть компактный вид" : "Расширить чат на всю ширину";

                widthToggleBtn.addEventListener('click', () => {
                    state.isChatWidthCompact = !state.isChatWidthCompact;
                    const isNowExpanded = !state.isChatWidthCompact;

                    localStorage.setItem('chatViewCompact', state.isChatWidthCompact);

                    messagesContainer?.classList.toggle('chat-view-compact', state.isChatWidthCompact);
                    widthToggleBtn.classList.toggle('active', isNowExpanded);

                    widthToggleBtn.title = isNowExpanded ? "Вернуть компактный вид" : "Расширить чат на всю ширину";
                });
            }

            settingsToggle?.addEventListener('click', () => {
                state.isSettingsPanelExpanded = !state.isSettingsPanelExpanded;
                settingsPanel.classList.toggle('expanded');
                settingsIcon.classList.toggle('expanded');
            });

            form?.addEventListener('submit', handleChatSubmit);
            input?.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && e.ctrlKey) {
                    e.preventDefault();
                    form.requestSubmit();
                }
            });

            if (input && form && messagesContainer && chatViewContainer) {
                const adjustLayout = () => {
                    if (!form || !messagesContainer || !input || !chatViewContainer) return;

                    const chatHeader = chatViewContainer.querySelector('.flex-shrink-0.p-3.border-b');
                    if (!chatHeader) return;

                    const MIN_MESSAGES_HEIGHT = 40;
                    const maxFormHeight = chatViewContainer.offsetHeight - chatHeader.offsetHeight - MIN_MESSAGES_HEIGHT;

                    const formStyle = window.getComputedStyle(form);
                    const formVerticalPadding = parseFloat(formStyle.paddingTop) + parseFloat(formStyle.paddingBottom);
                    const maxTextareaHeight = maxFormHeight - formVerticalPadding;

                    input.style.height = 'auto';
                    const newHeight = Math.min(input.scrollHeight, maxTextareaHeight);
                    input.style.height = `${newHeight}px`;

                    setTimeout(() => {
                        const formHeight = form.offsetHeight;
                        messagesContainer.style.paddingBottom = `${formHeight}px`;

                        const fadeHeight = 30; // Высота зоны затухания в пикселях
                        const maskValue = `linear-gradient(to bottom, 
                            transparent, 
                            black 50px, 
                            black calc(100% - ${formHeight + fadeHeight}px), 
                            transparent calc(100% - ${formHeight}px))`;
                        
                        messagesContainer.style.webkitMaskImage = maskValue;
                        messagesContainer.style.maskImage = maskValue;
                    }, 0);
                };

                input.addEventListener('input', adjustLayout);

                const resizeObserver = new ResizeObserver(adjustLayout);
                resizeObserver.observe(chatViewContainer);

                setTimeout(adjustLayout, 50);
            }

            titleInput?.addEventListener('change', (e) => { const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId); updateDoc(sessionRef, { title: e.target.value }); });

            roleSelect?.addEventListener('change', (e) => {
                const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
                updateDoc(sessionRef, { roleId: e.target.value });
            });

            providerSelect?.addEventListener('change', (e) => {
                const newProviderId = e.target.value;
                const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
                const selectedProvider = state.providers.find(p => p.id === newProviderId);
                let newModelName = null;

                if (selectedProvider) {
                    const models = selectedProvider.models || [];
                    if (models.length > 0) {
                        newModelName = models[0];
                        if (modelSelect) {
                            modelSelect.innerHTML = models.map(m => `<option value="${m}">${m}</option>`).join('');
                        }
                    } else {
                        if (modelSelect) {
                            modelSelect.innerHTML = '<option disabled>Нет моделей</option>';
                        }
                    }
                }
                updateDoc(sessionRef, { providerId: newProviderId, modelName: newModelName });
            });

            modelSelect?.addEventListener('change', (e) => {
                const newModelName = e.target.value;
                const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
                updateDoc(sessionRef, { modelName: newModelName });
            });
        }
        
        function setupNotepadViewEventListeners() {
            const titleInput = document.getElementById('note-title-input');
            const cardsGrid = document.getElementById('note-cards-grid');
            const addNewCardBtn = document.getElementById('add-new-card-btn');
            const widthToggleBtn = document.getElementById('notepad-width-toggle');
            const scrollContainer = document.getElementById('notepad-scroll-container');

            if(widthToggleBtn && scrollContainer) {
                const isExpanded = !state.isNotepadWidthCompact;
                widthToggleBtn.classList.toggle('active', isExpanded);
                widthToggleBtn.title = isExpanded ? "Вернуть компактный вид" : "Расширить на всю ширину";
        
                widthToggleBtn.addEventListener('click', () => {
                    state.isNotepadWidthCompact = !state.isNotepadWidthCompact;
                    const isNowExpanded = !state.isNotepadWidthCompact;
        
                    localStorage.setItem('notepadViewCompact', String(state.isNotepadWidthCompact));
        
                    scrollContainer.classList.toggle('notepad-view-compact', state.isNotepadWidthCompact);
                    widthToggleBtn.classList.toggle('active', isNowExpanded);
        
                    widthToggleBtn.title = isNowExpanded ? "Вернуть компактный вид" : "Расширить на всю ширину";
                });
            }
            
            const debounce = (func, delay) => {
                let timeoutId;
                return (...args) => {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => {
                        func.apply(this, args);
                    }, delay);
                };
            };
            
            const saveCardData = async (cardId) => {
                if (!state.activeSessionId) return;
                const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);

                const cardEl = cardsGrid.querySelector(`.note-card[data-card-id="${cardId}"]`);
                if (!cardEl) return;
        
                const activeSession = state.sessions.find(s => s.id === state.activeSessionId);
                if (!activeSession || !activeSession.cards) return;
        
                const newTitle = cardEl.querySelector('.note-card-title').value;
                const newContent = cardEl.querySelector('.note-card-content').value;
        
                const originalCard = activeSession.cards.find(c => c.id === cardId);
                
                if (originalCard && (originalCard.title !== newTitle || originalCard.content !== newContent)) {
                    const updatedCards = activeSession.cards.map(card => 
                        card.id === cardId ? { ...card, title: newTitle, content: newContent } : card
                    );
                    await updateDoc(sessionRef, { cards: updatedCards, updatedAt: serverTimestamp() });
                }
            };
            
            const debouncedSave = debounce(saveCardData, 750);
            
            function autoResizeTextarea(textarea) {
                if (!textarea) return;
                textarea.style.height = 'auto';
                textarea.style.height = (textarea.scrollHeight) + 'px';
            }

            titleInput?.addEventListener('change', () => {
                if (!state.activeSessionId) return;
                const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
                updateDoc(sessionRef, { title: titleInput.value, updatedAt: serverTimestamp() });
            });
        
            addNewCardBtn?.addEventListener('click', async () => {
                if (!state.activeSessionId) return;
                const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);

                const newCard = {
                    id: 'card_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9),
                    title: '',
                    content: '',
                    createdAt: new Date().toISOString()
                };
                
                await updateDoc(sessionRef, {
                    cards: arrayUnion(newCard),
                    updatedAt: serverTimestamp()
                });
            });
            
            cardsGrid?.addEventListener('focusout', (e) => {
                const cardEl = e.target.closest('.note-card');
                if (cardEl && e.target.matches('.note-card-title, .note-card-content')) {
                    saveCardData(cardEl.dataset.cardId);
                }
            });
        
            cardsGrid?.addEventListener('click', (e) => {
                const deleteBtn = e.target.closest('.note-card-delete-btn');
                if (!deleteBtn) return;
        
                const cardEl = deleteBtn.closest('.note-card');
                const cardId = cardEl.dataset.cardId;
        
                showConfirmModal('Вы уверены, что хотите удалить эту карточку?', async () => {
                    if (!state.activeSessionId) return;
                    const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);

                    const activeSession = state.sessions.find(s => s.id === state.activeSessionId);
                    const cards = activeSession.cards || [];
                    const cardToDelete = cards.find(c => c.id === cardId);
        
                    if (cardToDelete) {
                        await updateDoc(sessionRef, {
                            cards: arrayRemove(cardToDelete),
                            updatedAt: serverTimestamp()
                        });
                    }
                });
            });
            
            cardsGrid?.addEventListener('input', (e) => {
                if (!e.target) return;
                const cardEl = e.target.closest('.note-card');
                
                if (e.target.matches('.note-card-content')) {
                    autoResizeTextarea(e.target);
                }
                
                if (cardEl && e.target.matches('.note-card-title, .note-card-content')) {
                    debouncedSave(cardEl.dataset.cardId);
                }
            });

            setTimeout(() => {
                const allTextareas = cardsGrid?.querySelectorAll('.note-card-content');
                allTextareas?.forEach(autoResizeTextarea);
            }, 0);

            lucide.createIcons();
        }
    
        function setupSettingsViewEventListeners() { 
            document.getElementById('add-new-provider-btn')?.addEventListener('click', handleAddProvider);
            document.getElementById('add-new-role-btn')?.addEventListener('click', handleAddRole);
        }
        
        async function handleChatSubmit(e) {
            e.preventDefault();
            const input = document.getElementById('chat-input');
            const messageContent = input.value.trim();
            if (!messageContent || state.loadingSessionId) return;

            const activeSession = state.sessions.find(s => s.id === state.activeSessionId);
            const provider = state.providers.find(p => p.id === activeSession.providerId);
            const selectedRole = state.roles.find(r => r.id === activeSession.roleId);

            const userMessage = { role: 'user', content: messageContent };
            const messagesToSubmit = [...(activeSession.messages || []), userMessage];
            
            input.value = '';
            input.style.height = 'auto';

            const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
            await updateDoc(sessionRef, { messages: messagesToSubmit, updatedAt: serverTimestamp() });

            // Передаем все нужные данные напрямую
            await generateAssistantResponse(
                state.activeSessionId,
                messagesToSubmit,
                provider,
                selectedRole,
                activeSession.modelName
            );
        }

        async function generateAssistantResponse(sessionId, messagesToSubmit, provider, selectedRole, modelName) {
            if (state.loadingSessionId) return;

            generationAbortController = new AbortController();
            const signal = generationAbortController.signal;

            state.loadingSessionId = sessionId;
            render();

            let assistantMessageContent = '';
            let isSuccess = false;
            let wasAborted = false;
            let lastError = 'Неизвестная ошибка.';

            try {
                if (!provider) throw new Error("Провайдер API не найден или не выбран.");
                if (!modelName) throw new Error("Модель не выбрана.");
                
                const apiKeys = provider.apiKeys || [];
                if (apiKeys.length === 0) throw new Error("У выбранного провайдера нет API ключей.");

                const apiMessagesPayload = [];
                if (selectedRole && selectedRole.content) {
                    apiMessagesPayload.push({ role: 'system', content: selectedRole.content });
                }
                apiMessagesPayload.push(...messagesToSubmit.map(m => ({ role: m.role, content: m.content })));

                const startIndex = provider.currentKeyIndex || 0;
                for (let i = 0; i < apiKeys.length; i++) {
                    if (signal.aborted) throw new Error('AbortError');

                    const keyIndex = (startIndex + i) % apiKeys.length;
                    const currentKey = apiKeys[keyIndex];

                    try {
                        const fullUrl = new URL(provider.path, provider.baseUrl).href;
                        const proxyRequestBody = {
                            targetUrl: fullUrl,
                            apiKey: currentKey,
                            payload: { model: modelName, messages: apiMessagesPayload }
                        };
                        const response = await fetch('/api/proxy', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(proxyRequestBody),
                            signal: signal
                        });

                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({ message: `Статус ${response.status}` }));
                            throw new Error(`Ошибка от прокси: ${errorData.message || JSON.stringify(errorData)}`);
                        }
                        const data = await response.json();
                        if (data.error) throw new Error(`Ошибка от API: ${data.error.message || JSON.stringify(data.error)}`);
                        
                        assistantMessageContent = data.choices[0].message.content;
                        isSuccess = true;
                        const providerRef = doc(db, `artifacts/${appId}/users/${userId}/providers`, provider.id);
                        await updateDoc(providerRef, { currentKeyIndex: (keyIndex + 1) % apiKeys.length });
                        break;
                    } catch (error) {
                        if (error.message === 'AbortError') throw error;
                        console.error(`Попытка с ключом ${keyIndex + 1}/${apiKeys.length} не удалась:`, error);
                        lastError = error.message;
                    }
                }
                if (!isSuccess && !signal.aborted) throw new Error(lastError);

            } catch (error) {
                if (error.message === 'AbortError' || error.name === 'AbortError') {
                    console.log('Генерация остановлена пользователем.');
                    wasAborted = true;
                    lastError = 'Генерация остановлена пользователем.';
                } else {
                    console.error("Ошибка в generateAssistantResponse:", error);
                    lastError = error.message;
                }
            } finally {
                const messageToAdd = wasAborted
                    ? { role: 'assistant', content: `*Генерация была остановлена.*`, modelName: modelName }
                    : isSuccess
                        ? { role: 'assistant', content: assistantMessageContent, modelName: modelName }
                        : { role: 'assistant', content: `**Ошибка:** Не удалось получить ответ. \n\n*Детали: ${lastError}*`, modelName: modelName };
                
                const finalMessages = [...messagesToSubmit, messageToAdd];
                const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, sessionId);
                await updateDoc(sessionRef, { messages: finalMessages, updatedAt: serverTimestamp() });

                if (isSuccess && (document.hidden || state.activeSessionId !== sessionId || state.activeTab !== 'chat')) {
                    const session = state.sessions.find(s => s.id === sessionId);
                    const chatTitle = session?.title || 'Новый чат';
                    const messagePreview = (assistantMessageContent || '').replace(/<[^>]*>/g, '').replace(/[#*`~_]/g, '').substring(0, 100);
                    showInAppNotification(`Новый ответ в чате "${chatTitle}"`, messagePreview, sessionId);
                }

                state.loadingSessionId = null;
                generationAbortController = null;
                render();
            }
        }
        
        function showTypingIndicatorInChat() {
            const messagesContainer = document.getElementById('chat-messages');
            if (!messagesContainer) return;

            const oldIndicator = document.getElementById('loading-message-placeholder');
            if(oldIndicator) oldIndicator.remove();

            const indicatorHtml = `
                <div id="loading-message-placeholder" class="message-container flex items-start space-x-4 mb-6">
                    <div class="w-10 h-10 rounded-full bg-accent flex-shrink-0 flex items-center justify-center">
                        <i data-lucide="sparkles" class="w-6 h-6 text-white"></i>
                    </div>
                    <div class="pt-2 typing-indicator">
                        <span></span><span></span><span></span>
                    </div>
                </div>
            `;
            messagesContainer.insertAdjacentHTML('beforeend', indicatorHtml);
            lucide.createIcons();
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function updateLoadingIndicator() {
            const form = document.getElementById('chat-form');
            if (!form) return;

            const button = form.querySelector('button[type="submit"], button[type="button"]');
            const textarea = form.querySelector('textarea');
            const isLoadingThisSession = state.loadingSessionId === state.activeSessionId;

            if (textarea) textarea.disabled = isLoadingThisSession;
            if (button) {
                button.disabled = false; // Кнопка всегда активна для нажатия (отправка/стоп)
                if (isLoadingThisSession) {
                    button.setAttribute('type', 'button');
                    button.title = 'Остановить генерацию';
                    button.innerHTML = '<i data-lucide="square" class="w-5 h-5 text-white"></i>';

                    const stopHandler = (e) => {
                        e.preventDefault();
                        if(generationAbortController) generationAbortController.abort();
                    };
                    // Удаляем старый обработчик, чтобы избежать дублирования
                    button.replaceWith(button.cloneNode(true));
                    form.querySelector('button').addEventListener('click', stopHandler);

                } else {
                    button.setAttribute('type', 'submit');
                    button.title = 'Отправить';
                    button.innerHTML = '<i data-lucide="send" class="w-5 h-5 text-white"></i>';
                }
                lucide.createIcons();
            }
            
            const typingIndicator = document.getElementById('loading-message-placeholder');
            if (typingIndicator) typingIndicator.remove();
            
            if (isLoadingThisSession) {
                showTypingIndicatorInChat();
            }
        }        
        
        async function handleAddProvider() {
            if (state.isLoading) return;
            state.isLoading = true;
            try {
                const newProviderData = {
                    name: 'Новый провайдер',
                    baseUrl: 'https://api.openai.com',
                    path: '/v1/chat/completions',
                    apiKeys: [],
                    models: ['gpt-4o', 'gpt-3.5-turbo'],
                    currentKeyIndex: 0
                };
                const docRef = await addDoc(collection(db, `artifacts/${appId}/users/${userId}/providers`), newProviderData);
                handleOpenEditProviderModal(docRef.id);
            } catch (error) {
                console.error("Ошибка при добавлении провайдера: ", error);
                showModalAlert("Не удалось создать провайдера.");
            } finally {
                state.isLoading = false;
            }
        }
        
        async function handleAddRole() {
            if (state.isLoading) return;
            state.isLoading = true;
            try {
                const newRoleData = {
                    name: 'Новая роль',
                    content: 'Ты — полезный ассистент.',
                    createdAt: serverTimestamp()
                };
                const docRef = await addDoc(collection(db, `artifacts/${appId}/users/${userId}/roles`), newRoleData);
                handleOpenEditRoleModal(docRef.id);
            } catch (error) {
                console.error("Ошибка при добавлении роли: ", error);
                showModalAlert("Не удалось создать роль.");
            } finally {
                state.isLoading = false;
            }
        }
        
        function handleOpenEditProviderModal(providerId) {
            const providerToEdit = state.providers.find(p => p.id === providerId);
            if (!providerToEdit) return;
            
            const apiKeysArray = providerToEdit.apiKeys || [];
            const modelsArray = providerToEdit.models || (providerToEdit.model ? [providerToEdit.model] : []);
            
            document.getElementById('edit-provider-id').value = providerToEdit.id;
            document.getElementById('edit-provider-name').value = providerToEdit.name;
            document.getElementById('edit-provider-url').value = providerToEdit.baseUrl;
            document.getElementById('edit-provider-path').value = providerToEdit.path;
            document.getElementById('edit-provider-keys').value = apiKeysArray.join('\n');
            document.getElementById('edit-provider-models').value = modelsArray.join('\n');
            
            editProviderModal.classList.remove('hidden');
        }
    
        function handleOpenEditRoleModal(roleId) {
            const roleToEdit = state.roles.find(r => r.id === roleId);
            if (!roleToEdit) return;
    
            document.getElementById('edit-role-id').value = roleToEdit.id;
            document.getElementById('edit-role-name').value = roleToEdit.name;
            document.getElementById('edit-role-content').value = roleToEdit.content;
    
            editRoleModal.classList.remove('hidden');
        }
    
        async function handleEditProviderSubmit(e) {
            e.preventDefault();
            const providerId = document.getElementById('edit-provider-id').value;
            if (!providerId) return;
    
            const name = document.getElementById('edit-provider-name').value;
            const baseUrl = document.getElementById('edit-provider-url').value;
            const path = document.getElementById('edit-provider-path').value;
            const keysRaw = document.getElementById('edit-provider-keys').value;
            const modelsRaw = document.getElementById('edit-provider-models').value;
    
            const apiKeys = keysRaw.split(/\r?\n/).map(k => k.trim()).filter(k => k.length > 0);
            if (apiKeys.length === 0) {
                showModalAlert("Пожалуйста, введите хотя бы один API ключ.");
                return;
            }
            
            const models = modelsRaw.split(/\r?\n/).map(m => m.trim()).filter(m => m.length > 0);
            if (models.length === 0) {
                showModalAlert("Пожалуйста, введите хотя бы одну модель.");
                return;
            }

            const providerRef = doc(db, `artifacts/${appId}/users/${userId}/providers`, providerId);
            const originalProvider = state.providers.find(p => p.id === providerId);
            const originalKeys = originalProvider.apiKeys || [];
            const keysChanged = JSON.stringify(originalKeys.sort()) !== JSON.stringify(apiKeys.sort());

            const updatedData = { name, baseUrl, path, apiKeys, models, model: deleteField() };
            if (keysChanged) { updatedData.currentKeyIndex = 0; }

            await updateDoc(providerRef, updatedData);
            editProviderModal.classList.add('hidden');
        }
    
        async function handleEditRoleSubmit(e) {
            e.preventDefault();
            const roleId = document.getElementById('edit-role-id').value;
            if (!roleId) return;
    
            const name = document.getElementById('edit-role-name').value;
            const content = document.getElementById('edit-role-content').value;
    
            const roleRef = doc(db, `artifacts/${appId}/users/${userId}/roles`, roleId);
            await updateDoc(roleRef, { name, content });
            editRoleModal.classList.add('hidden');
        }
    
        function copyToClipboard(text) { navigator.clipboard.writeText(text).catch(err => console.error('Не удалось скопировать текст: ', err)); }
        function showConfirmModal(message, onConfirm) { confirmModalText.textContent = message; confirmModalCallback = onConfirm; confirmModal.classList.remove('hidden'); }
        function hideConfirmModal() { confirmModal.classList.add('hidden'); confirmModalCallback = null; }
        function showModalAlert(message) { confirmModalText.textContent = message; confirmModalYesBtn.classList.add('hidden'); confirmModalNoBtn.textContent = 'OK'; confirmModal.classList.remove('hidden'); confirmModalCallback = () => { confirmModalYesBtn.classList.remove('hidden'); confirmModalNoBtn.textContent = 'Нет'; }; }
    
        function updateSidebarView() {
            const isMobile = window.innerWidth < 1024;
            const toggleIcon = document.getElementById('sidebar-toggle-icon');
            if (isMobile) {
                sidebar.classList.remove('collapsed');
                toggleIcon.setAttribute('data-lucide', 'menu');
            } else {
                sidebar.classList.remove('open');
                sidebarBackdrop.classList.add('hidden');
                sidebar.classList.toggle('collapsed', state.isSidebarCollapsed);
                toggleIcon.setAttribute('data-lucide', state.isSidebarCollapsed ? 'panel-right-close' : 'panel-left-close');
            }
            lucide.createIcons();
        }

        /**
         * Показывает кастомное уведомление (плашку) внутри приложения.
         * @param {string} title - Заголовок уведомления.
         * @param {string} body - Текст уведомления.
         * @param {string} sessionId - ID сессии, на которую нужно переключиться по клику.
         */
        function showInAppNotification(title, body, sessionId) {
            // Очищаем любой предыдущий таймер, чтобы новые уведомления не скрывались преждевременно
            if (notificationTimeout) {
                clearTimeout(notificationTimeout);
            }

            // Находим исходный элемент уведомления в DOM
            const originalNotification = document.getElementById('in-app-notification');
            if (!originalNotification) {
                console.error("Элемент уведомления #in-app-notification не найден.");
                return;
            }

            // Клонируем узел, чтобы безопасно и чисто заменить обработчики событий
            const newNotification = originalNotification.cloneNode(true);

            // Находим дочерние элементы в новом, клонированном узле
            const titleEl = newNotification.querySelector('#in-app-notification-title');
            const bodyEl = newNotification.querySelector('#in-app-notification-body');
            const closeBtn = newNotification.querySelector('#in-app-notification-close');

            // Обновляем текст в клоне
            if(titleEl) titleEl.textContent = title;
            if(bodyEl) bodyEl.textContent = body;

            // Определяем функцию для скрытия уведомления
            const hideNotification = () => {
                newNotification.classList.add('-translate-y-[150%]', 'opacity-0');
                // После завершения анимации (300ms) снова добавляем класс 'hidden',
                // чтобы он не мешал взаимодействию с другими элементами.
                setTimeout(() => {
                    if(newNotification.parentNode) { // Убедимся, что узел все еще в DOM
                       newNotification.classList.add('hidden');
                    }
                }, 300);
            };

            // Добавляем обработчики событий на новый узел
            newNotification.addEventListener('click', () => {
                state.activeTab = 'chat';
                state.activeSessionId = sessionId;
                render();
                hideNotification();
            });

            if(closeBtn) {
                closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Предотвращаем клик по родительскому элементу
                    hideNotification();
                });
            }

            // Заменяем старый узел в DOM на новый, полностью настроенный узел
            originalNotification.parentNode.replaceChild(newNotification, originalNotification);
            
            // Восстанавливаем иконки, которые были потеряны при клонировании
            lucide.createIcons({ nodes: [newNotification] });

            // --- Ключевой момент для запуска анимации ---
            // 1. Сначала убираем 'hidden', чтобы элемент появился в потоке документа (например, display: flex).
            newNotification.classList.remove('hidden');
            
            // 2. Используем setTimeout с нулевой задержкой. Это заставляет браузер
            // обработать изменение display, выполнить перерасчет стилей, и только
            // на следующем "тике" выполнить код внутри. Это гарантирует,
            // что CSS-переход (transition) будет запущен корректно.
            setTimeout(() => {
                newNotification.classList.remove('-translate-y-[150%]', 'opacity-0');
            }, 0); 

            // Устанавливаем таймер на автоматическое скрытие уведомления
            notificationTimeout = setTimeout(hideNotification, 7000);
        }
    
        function setupGlobalEventListeners() {
            mainNavItems.forEach(item => {
                item.addEventListener('click', () => {
                    state.activeTab = item.dataset.tab;
                    if (state.activeTab === 'chat' || state.activeTab === 'notepad') {
                        const firstSessionOfType = state.sessions.find(s => s.type === state.activeTab);
                        state.activeSessionId = firstSessionOfType ? firstSessionOfType.id : null;
                    } else {
                        state.activeSessionId = null;
                    }
                    render();
                });
            });
        
            const createNewItem = async (type) => {
                let newSessionData;
                if (type === 'chat') {
                    let providerId = null;
                    let modelName = null;
                    if (state.providers.length > 0) {
                        const firstProvider = state.providers[0];
                        providerId = firstProvider.id;
                        const models = firstProvider.models || [];
                        if (models.length > 0) {
                            modelName = models[0];
                        }
                    }
                    newSessionData = { type: 'chat', title: 'Новый чат', messages: [], providerId, modelName, roleId: '', createdAt: serverTimestamp(), updatedAt: serverTimestamp() };
                } else if (type === 'notepad') {
                    newSessionData = { 
                        type: 'notepad', 
                        title: 'Новая папка', 
                        cards: [],
                        createdAt: serverTimestamp(), 
                        updatedAt: serverTimestamp() 
                    };
                }
                
                const newSessionRef = await addDoc(collection(db, `artifacts/${appId}/users/${userId}/sessions`), newSessionData);
                state.activeSessionId = newSessionRef.id;
                
                render();
                if (window.innerWidth < 1024) { 
                    sidebar.classList.remove('open'); 
                    sidebarBackdrop.classList.remove('active'); 
                }
            };
        
            newChatBtn.addEventListener('click', () => createNewItem('chat'));
            newNoteBtn.addEventListener('click', () => createNewItem('notepad'));
            
            document.getElementById('sidebar-toggle-btn').addEventListener('click', () => {
                if (window.innerWidth < 1024) {
                    sidebar.classList.toggle('open');
                    sidebarBackdrop.classList.toggle('active'); // <-- СТАЛО
                } else {
                    state.isSidebarCollapsed = !state.isSidebarCollapsed;
                    updateSidebarView();
                }
            });
        
            sidebarBackdrop.addEventListener('click', () => {
                sidebar.classList.remove('open');
                sidebarBackdrop.classList.remove('active');
            });
            
            window.addEventListener('resize', updateSidebarView);
        
            document.body.addEventListener('click', async (e) => {
                const deleteSessionBtn = e.target.closest('.delete-session-btn');
                if (deleteSessionBtn) {
                    const idToDelete = deleteSessionBtn.dataset.id;
                    showConfirmModal('Вы уверены, что хотите удалить этот элемент?', async () => {
                        await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/sessions`, idToDelete));
                    });
                }
                
                const deleteMessageBtn = e.target.closest('.delete-message-btn');
                if (deleteMessageBtn) {
                    const messageIndex = parseInt(deleteMessageBtn.dataset.messageIndex, 10);
                    const activeSession = state.sessions.find(s => s.id === state.activeSessionId);
        
                    if (activeSession && !isNaN(messageIndex)) {
                        showConfirmModal('Вы уверены, что хотите удалить это сообщение?', async () => {
                            const newMessages = activeSession.messages.filter((_, index) => index !== messageIndex);
                            const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
                            await updateDoc(sessionRef, { messages: newMessages });
                        });
                    }
                }
    
                const handleRegeneration = (messageIndex, sliceEnd) => {
                    if (state.loadingSessionId) return;
                    const activeSession = state.sessions.find(s => s.id === state.activeSessionId);
                    if (!activeSession || isNaN(messageIndex)) return;
    
                    const confirmationText = sliceEnd === messageIndex
                        ? 'Вы уверены, что хотите перегенерировать этот ответ? Текущий ответ будет удален.'
                        : 'Это действие удалит все сообщения после этого и сгенерирует новый ответ. Продолжить?';
    
                    showConfirmModal(confirmationText, async () => {
                        const messagesForRegen = activeSession.messages.slice(0, sliceEnd);
                        const provider = state.providers.find(p => p.id === activeSession.providerId);
                        const selectedRole = state.roles.find(r => r.id === activeSession.roleId);
    
                        const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
                        await updateDoc(sessionRef, { messages: messagesForRegen, updatedAt: serverTimestamp() });
                        
                        await generateAssistantResponse(
                            state.activeSessionId,
                            messagesForRegen,
                            provider,
                            selectedRole,
                            activeSession.modelName
                        );
                    });
                };
                
                const regenerateUserBtn = e.target.closest('.regenerate-user-message-btn');
                if (regenerateUserBtn) {
                    const messageIndex = parseInt(regenerateUserBtn.dataset.messageIndex, 10);
                    handleRegeneration(messageIndex, messageIndex + 1);
                }
    
                const regenerateBtn = e.target.closest('.regenerate-message-btn');
                if (regenerateBtn) {
                    const messageIndex = parseInt(regenerateBtn.dataset.messageIndex, 10);
                    handleRegeneration(messageIndex, messageIndex);
                }
        
                const editBtn = e.target.closest('.edit-message-btn');
                if (editBtn) {
                    if (state.loadingSessionId) return;
                    const messageContainer = editBtn.closest('.message-container');
                    const contentDiv = messageContainer.querySelector('.prose');
                    if (messageContainer.querySelector('.edit-form')) return; 
        
                    const messageIndex = parseInt(editBtn.dataset.messageIndex, 10);
                    const activeSession = state.sessions.find(s => s.id === state.activeSessionId);
                    const originalContent = activeSession.messages[messageIndex].content;
        
                    contentDiv.classList.add('hidden');
        
                    const editForm = document.createElement('div');
                    editForm.className = 'edit-form w-full mt-2';
                    editForm.innerHTML = `
                        <textarea class="w-full bg-input border border-border-color rounded-lg p-3 resize-none focus:outline-none focus:ring-2 focus:ring-accent" rows="3"></textarea>
                        <div class="flex justify-end items-center mt-2 space-x-2">
                             <button class="cancel-edit-btn px-3 py-1 rounded-md bg-bg-input hover:bg-gray-600 transition-colors text-sm">Отмена</button>
                             <button class="save-edit-btn px-3 py-1 rounded-md bg-accent hover:bg-accent-hover text-white transition-colors text-sm">Сохранить и отправить</button>
                        </div>
                    `;
                    contentDiv.after(editForm);
                    
                    const textarea = editForm.querySelector('textarea');
                    textarea.value = originalContent;
                    textarea.focus();
                    textarea.style.height = 'auto';
                    textarea.style.height = (textarea.scrollHeight) + 'px';
                    textarea.addEventListener('input', () => {
                       textarea.style.height = 'auto';
                       textarea.style.height = (textarea.scrollHeight) + 'px';
                    });
        
                    editForm.querySelector('.save-edit-btn').addEventListener('click', async () => {
                        const newContent = textarea.value.trim();
                        if (newContent) {
                            const messagesForSubmit = activeSession.messages.slice(0, messageIndex);
                            messagesForSubmit.push({ role: 'user', content: newContent });
                            
                            const provider = state.providers.find(p => p.id === activeSession.providerId);
                            const selectedRole = state.roles.find(r => r.id === activeSession.roleId);
    
                            const sessionRef = doc(db, `artifacts/${appId}/users/${userId}/sessions`, state.activeSessionId);
                            await updateDoc(sessionRef, { messages: messagesForSubmit, updatedAt: serverTimestamp() });
                            
                            await generateAssistantResponse(
                                state.activeSessionId,
                                messagesForSubmit,
                                provider,
                                selectedRole,
                                activeSession.modelName
                            );
                        }
                    });
        
                    editForm.querySelector('.cancel-edit-btn').addEventListener('click', () => {
                        editForm.remove();
                        contentDiv.classList.remove('hidden');
                    });
                }
                
                const deleteProviderBtn = e.target.closest('.delete-provider-btn');
                if (deleteProviderBtn) {
                    const idToDelete = deleteProviderBtn.dataset.id;
                    showConfirmModal('Вы уверены, что хотите удалить этого провайдера?', async () => {
                        await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/providers`, idToDelete));
                    });
                }
                const editProviderBtn = e.target.closest('.edit-provider-btn');
                if (editProviderBtn) {
                    const idToEdit = editProviderBtn.dataset.id;
                    handleOpenEditProviderModal(idToEdit);
                }
                
                const deleteRoleBtn = e.target.closest('.delete-role-btn');
                if (deleteRoleBtn) {
                    const idToDelete = deleteRoleBtn.dataset.id;
                    showConfirmModal('Вы уверены, что хотите удалить эту роль?', async () => {
                        await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/roles`, idToDelete));
                    });
                }
                const editRoleBtn = e.target.closest('.edit-role-btn');
                if (editRoleBtn) {
                    const idToEdit = editRoleBtn.dataset.id;
                    handleOpenEditRoleModal(idToEdit);
                }
            });
            
            confirmModalYesBtn.addEventListener('click', () => { if (confirmModalCallback) { confirmModalCallback(); } hideConfirmModal(); });
            confirmModalNoBtn.addEventListener('click', () => { if(confirmModalNoBtn.textContent === 'OK') { if (confirmModalCallback) confirmModalCallback(); } hideConfirmModal(); });
            
            editProviderForm?.addEventListener('submit', handleEditProviderSubmit);
            editProviderCancelBtn?.addEventListener('click', () => { editProviderModal.classList.add('hidden'); });
        
            editRoleForm?.addEventListener('submit', handleEditRoleSubmit);
            editRoleCancelBtn?.addEventListener('click', () => { editRoleModal.classList.add('hidden'); });
        
            document.getElementById('google-signin-btn')?.addEventListener('click', async () => { try { const provider = new GoogleAuthProvider(); await signInWithPopup(auth, provider); } catch (error) { console.error("Google sign-in error", error); showModalAlert("Не удалось войти через Google. Ошибка: " + error.message); }});
            document.getElementById('sign-out-btn')?.addEventListener('click', async (e) => { e.preventDefault(); try { await signOut(auth); } catch (error) { console.error("Sign-out error", error); }});
        }
        
        function attachFirestoreListeners() {
            unsubscribeSessions(); unsubscribeProviders(); unsubscribeRoles();
            if (!userId) return;
        
            const sessionsCol = collection(db, `artifacts/${appId}/users/${userId}/sessions`);
            unsubscribeSessions = onSnapshot(sessionsCol, (snapshot) => {
                state.sessions = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))
                    .sort((a,b) => (b.updatedAt?.toMillis() || 0) - (a.updatedAt?.toMillis() || 0));
        
                const activeSessionExists = state.sessions.some(s => s.id === state.activeSessionId);
                if (!activeSessionExists) {
                    state.activeSessionId = null;
                }
                if (!state.isLoading) {
                    render();
                }
            }, error => console.error("Session listener error: ", error));
        
            const providersCol = collection(db, `artifacts/${appId}/users/${userId}/providers`);
            unsubscribeProviders = onSnapshot(providersCol, (snapshot) => {
                state.providers = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                if ((state.activeTab === 'settings' || state.activeTab === 'chat') && !state.isLoading) {
                    render();
                }
            }, error => console.error("Providers listener error: ", error));
        
            const rolesCol = collection(db, `artifacts/${appId}/users/${userId}/roles`);
            unsubscribeRoles = onSnapshot(rolesCol, (snapshot) => {
                state.roles = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })).sort((a, b) => (a.createdAt?.toMillis() || 0) - (b.createdAt?.toMillis() || 0));
                if ((state.activeTab === 'settings' || state.activeTab === 'chat') && !state.isLoading) {
                    render();
                }
            }, error => console.error("Roles listener error: ", error));
        }
    
        function resetState() {
            unsubscribeSessions(); unsubscribeProviders(); unsubscribeRoles();
            if (chatObserver) {
                chatObserver.disconnect();
                chatObserver = null;
            }
            userId = null;
            state = { activeTab: 'chat', activeSessionId: null, sessions: [], providers: [], roles: [], isLoading: false, isAuthReady: false, isSidebarCollapsed: false };
            sidebar.classList.remove('collapsed', 'open');
            sidebarList.innerHTML = '<div class="p-4 text-center text-gray-500">Пожалуйста, войдите, чтобы начать работу.</div>';
            mainContent.innerHTML = getEmptyStateHTML('chat');
        }
    
        async function init() {
            loadUserPreferences();
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                onAuthStateChanged(auth, (user) => {
                    const googleBtn = document.getElementById('google-signin-btn');
                    const userProfile = document.getElementById('user-profile');
                    const authSection = document.getElementById('auth-section');
                    authSection.classList.remove('hidden');
    
                    if (user) {
                        userId = user.uid;
                        googleBtn.classList.add('hidden');
                        userProfile.classList.remove('hidden');
                        document.getElementById('user-name').textContent = user.displayName || 'Анонимный пользователь';
                        document.getElementById('user-avatar').src = user.photoURL || `https://ui-avatars.com/api/?name=${user.displayName || 'A'}&background=random`;
                        
                        state.isAuthReady = true;
                        attachFirestoreListeners();
                    } else {
                        resetState();
                        googleBtn.classList.remove('hidden');
                        userProfile.classList.add('hidden');
                        state.isAuthReady = false; 
                        render();
                    }
                    renderMainNav(); 
                    updateSidebarView();
                });
                
                setupGlobalEventListeners();
    
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                mainContent.innerHTML = `<div class="p-4 text-red-400"><strong>Ошибка инициализации Firebase:</strong> ${error.message}.</div>`;
            }
        }
        
        init();
    </script>

</body>
</html>
